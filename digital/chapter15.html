<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 15: Memory Interface</title>
    <link rel="stylesheet" href="style.css">
    <!-- 
    ⚠️ 중요: PDF 전체 페이지 확인
    - PDF의 마지막 페이지 번호: 26
    - 이 HTML에 포함된 마지막 페이지: 26
    - 두 값이 일치합니다!
    -->
</head>
<body data-first-section="sec-overview">

<div class="sidebar">
    <div class="brand">⚡ Logic Master<br><span style="font-size:0.8rem; color:#94a3b8; font-weight:400;">Exam Edition</span></div>
    <div class="menu-label">Chapter 15. Memory Interface</div>
    <div class="nav-item active" onclick="showSection('sec-overview', this)"><span class="nav-icon">📖</span> 1. Memory Overview</div>
    <div class="nav-item" onclick="showSection('sec-devices', this)"><span class="nav-icon">💾</span> 2. Memory Devices</div>
    <div class="nav-item" onclick="showSection('sec-sram', this)"><span class="nav-icon">⚡</span> 3. SRAM & EPROM</div>
    <div class="nav-item" onclick="showSection('sec-dram', this)"><span class="nav-icon">🔄</span> 4. DRAM</div>
    <div class="nav-item" onclick="showSection('sec-flash', this)"><span class="nav-icon">💿</span> 5. Flash Memory</div>
    <div class="nav-item" onclick="showSection('sec-hierarchy', this)"><span class="nav-icon">📊</span> 6. Memory Hierarchy</div>
</div>

<div class="main">
    <!-- 섹션 1: Memory Overview -->
    <div id="sec-overview" class="section-container active">
        <div class="header"><h1>1. Memory Interface Overview</h1><p>프로세서와 메모리 간 인터페이스 기본 개념</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('memory-interface')">
                <span class="card-icon">🔌</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>Memory Interface</h3>
                <p>프로세서와 메모리 간 신호: Address bus, Data bus, Control signals.</p>
                <div class="btn-learn">인터페이스 보기 (page 1)</div>
            </div>
            <div class="card" onclick="openModal('z80-architecture')">
                <span class="card-icon">🏗️</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>Z80 Architecture</h3>
                <p>Z80 프로세서의 버스와 메모리 접근 구조.</p>
                <div class="btn-learn">Z80 구조 보기 (page 2~3)</div>
            </div>
            <div class="card" onclick="openModal('processor-memory')">
                <span class="card-icon">🔗</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>Processor and Memory</h3>
                <p>Lab board의 메모리 장치: SRAM, EEPROM.</p>
                <div class="btn-learn">프로세서-메모리 보기 (page 4~5)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 2: Memory Devices -->
    <div id="sec-devices" class="section-container">
        <div class="header"><h1>2. Memory Devices</h1><p>다양한 메모리 장치의 종류와 특성</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('memory-types')">
                <span class="card-icon">📚</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>Memory Devices Overview</h3>
                <p>ROM, PROM, EPROM, Flash, SRAM, DRAM 등 메모리 장치 분류.</p>
                <div class="btn-learn">메모리 종류 보기 (page 6)</div>
            </div>
            <div class="card" onclick="openModal('memory-comparison')">
                <span class="card-icon">⚖️</span>
                <div class="tag-container"><span class="tag exam">중요</span></div>
                <h3>Memory Comparison</h3>
                <p>SRAM, DRAM, Flash, HDD의 특성 비교표.</p>
                <div class="btn-learn">비교 분석 보기 (page 16)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 3: SRAM & EPROM -->
    <div id="sec-sram" class="section-container">
        <div class="header"><h1>3. SRAM & EPROM</h1><p>정적 RAM과 비휘발성 메모리</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('eprom')">
                <span class="card-icon">💾</span>
                <div class="tag-container"><span class="tag logic">구조</span></div>
                <h3>EPROM</h3>
                <p>Erasable Programmable ROM. UV로 지울 수 있는 비휘발성 메모리.</p>
                <div class="btn-learn">EPROM 구조 보기 (page 7~8)</div>
            </div>
            <div class="card" onclick="openModal('sram')">
                <span class="card-icon">⚡</span>
                <div class="tag-container"><span class="tag exam">시험 빈출</span></div>
                <h3>SRAM</h3>
                <p>Static RAM. Read/Write 동작과 타이밍 다이어그램.</p>
                <div class="btn-learn">SRAM 동작 보기 (page 9~10)</div>
            </div>
            <div class="card" onclick="openModal('z80-instruction')">
                <span class="card-icon">🔄</span>
                <div class="tag-container"><span class="tag logic">코드 분석</span></div>
                <h3>Z80 Instruction Cycle</h3>
                <p>M1, M2, M3 사이클과 메모리 접근 타이밍.</p>
                <div class="btn-learn">명령어 사이클 보기 (page 11~14)</div>
            </div>
            <div class="card" onclick="openModal('bus-arbitration')">
                <span class="card-icon">🚦</span>
                <div class="tag-container"><span class="tag logic">구조</span></div>
                <h3>Bus Arbitration</h3>
                <p>다중 마스터 장치 간 버스 공유 메커니즘.</p>
                <div class="btn-learn">버스 중재 보기 (page 15)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 4: DRAM -->
    <div id="sec-dram" class="section-container">
        <div class="header"><h1>4. DRAM (Dynamic RAM)</h1><p>동적 RAM의 구조와 접근 방식</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('dram-structure')">
                <span class="card-icon">🏗️</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>DRAM Structure</h3>
                <p>DRAM의 원리와 구조. Capacitor 기반 저장.</p>
                <div class="btn-learn">DRAM 구조 보기 (page 17)</div>
            </div>
            <div class="card" onclick="openModal('dram-access')">
                <span class="card-icon">🔄</span>
                <div class="tag-container"><span class="tag exam">시험 빈출</span><span class="tag core">Interactive</span></div>
                <h3>DRAM Access</h3>
                <p>RAS-CAS 타이밍. Precharge, Row access, Column access 과정.</p>
                <div class="btn-learn">접근 과정 보기 (page 18~20)</div>
            </div>
            <div class="card" onclick="openModal('dram-latency')">
                <span class="card-icon">⏱️</span>
                <div class="tag-container"><span class="tag exam">중요</span></div>
                <h3>DRAM Latency</h3>
                <p>DRAM 지연 시간의 구성 요소. Queue, Controller, Command 순서.</p>
                <div class="btn-learn">지연 시간 분석 (page 21)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 5: Flash Memory -->
    <div id="sec-flash" class="section-container">
        <div class="header"><h1>5. Flash Memory</h1><p>NAND Flash 메모리의 구조와 인터페이스</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('flash-structure')">
                <span class="card-icon">💿</span>
                <div class="tag-container"><span class="tag logic">구조</span></div>
                <h3>Flash Memory Structure</h3>
                <p>K9F1G08U0D 예제. Page, Block 구조와 성능 특성.</p>
                <div class="btn-learn">Flash 구조 보기 (page 22)</div>
            </div>
            <div class="card" onclick="openModal('flash-interface')">
                <span class="card-icon">🔌</span>
                <div class="tag-container"><span class="tag logic">코드 분석</span></div>
                <h3>Flash Interface</h3>
                <p>Erase, Program, Read 순서. Command 시퀀스와 상태 플래그.</p>
                <div class="btn-learn">인터페이스 보기 (page 23)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 6: Memory Hierarchy -->
    <div id="sec-hierarchy" class="section-container">
        <div class="header"><h1>6. Memory Hierarchy</h1><p>메모리 계층 구조와 성능 최적화</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('memory-hierarchy')">
                <span class="card-icon">📊</span>
                <div class="tag-container"><span class="tag exam">중요</span></div>
                <h3>Memory Hierarchy</h3>
                <p>레지스터, 캐시, 메인 메모리, 보조 저장장치의 계층 구조.</p>
                <div class="btn-learn">계층 구조 보기 (page 24~25)</div>
            </div>
            <div class="card" onclick="openModal('hierarchy-design')">
                <span class="card-icon">⚙️</span>
                <div class="tag-container"><span class="tag exam">중요</span></div>
                <h3>Hierarchy Design Principles</h3>
                <p>고성능 설계 원칙. 버퍼링과 전송 최적화.</p>
                <div class="btn-learn">설계 원칙 보기 (page 25~26)</div>
            </div>
        </div>
    </div>
</div>

<!-- 모달 오버레이 -->
<div class="modal-overlay" id="modalOverlay" onclick="window.closeModal()">
    <div class="modal-content" onclick="event.stopPropagation()">
        <div class="modal-header">
            <div class="modal-title" id="modalTitle">제목</div>
            <button class="close-btn" onclick="window.closeModal()">✕</button>
        </div>
        <div class="modal-body" id="modalBody">내용</div>
    </div>
</div>

<script src="common.js"></script>

<script>
    // ============================================
    // 1. 모달 제목 정의
    // ============================================
    window.modalTitles = {
        'memory-interface': 'Memory Interface',
        'z80-architecture': 'Z80 Architecture',
        'processor-memory': 'Processor and Memory',
        'memory-types': 'Memory Devices Overview',
        'memory-comparison': 'Memory Comparison',
        'eprom': 'EPROM (Erasable Programmable ROM)',
        'sram': 'SRAM (Static RAM)',
        'z80-instruction': 'Z80 Instruction Cycle',
        'bus-arbitration': 'Bus Arbitration',
        'dram-structure': 'DRAM Structure',
        'dram-access': 'DRAM Access',
        'dram-latency': 'DRAM Latency',
        'flash-structure': 'Flash Memory Structure',
        'flash-interface': 'Flash Interface',
        'memory-hierarchy': 'Memory Hierarchy',
        'hierarchy-design': 'Hierarchy Design Principles'
    };

    // ============================================
    // 2. 모달 콘텐츠 정의
    // ============================================
    window.contents = {
        'memory-interface': `
            <h3>Memory Interface (메모리 인터페이스)</h3>
            <p><strong>Memory Interface (메모리 인터페이스):</strong> 프로세서와 메모리 간 통신을 위한 신호 집합</p>
            <p><strong>Address Bus (주소 버스):</strong> 메모리 주소를 전달하는 버스</p>
            <p><strong>Data Bus (데이터 버스):</strong> 데이터를 전달하는 버스</p>
            <p><strong>Control Signals (제어 신호):</strong> 읽기/쓰기, 칩 선택 등의 제어 신호</p>
            
            <canvas id="cvs_memory_interface"></canvas>
            
            <div class="easy-explain">
                <h4>💡 메모리 인터페이스 구성</h4>
                <ul>
                    <li><strong>Address Bus:</strong> 어느 메모리 위치에 접근할지 지정</li>
                    <li><strong>Data Bus:</strong> 읽거나 쓸 데이터를 전달</li>
                    <li><strong>Control Signals:</strong> 읽기/쓰기, 칩 활성화 등을 제어</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>마이크로프로세서의 메모리 인터페이스 신호</h4>
                <ul>
                    <li><strong>Address Bus:</strong> 메모리 주소 지정</li>
                    <li><strong>Data Bus:</strong> 데이터 전송</li>
                    <li><strong>Control Signals:</strong> 메모리 접근 제어</li>
                </ul>
            </div>
        `,

        'z80-architecture': `
            <h3>Z80 Architecture (Z80 아키텍처)</h3>
            <p><strong>Z80:</strong> 8비트 마이크로프로세서</p>
            <p>버스와 메모리에서의 명령어 처리 구조를 이해합니다.</p>
            
            <div class="easy-explain">
                <h4>💡 Z80의 특징</h4>
                <ul>
                    <li>8비트 데이터 버스</li>
                    <li>16비트 주소 버스 (64KB 주소 공간)</li>
                    <li>버스와 메모리를 통한 명령어 처리</li>
                </ul>
            </div>
        `,

        'processor-memory': `
            <h3>Processor and Memory (프로세서와 메모리)</h3>
            <p><strong>Lab Board (실습 보드):</strong> 실습에 사용되는 하드웨어 보드</p>
            <p>Lab board에 사용되는 메모리 장치들입니다.</p>
            
            <div class="tech-note">
                <h4>Lab Board의 메모리 장치</h4>
                <ul>
                    <li><strong>SRAM (Static RAM):</strong> 정적 랜덤 액세스 메모리</li>
                    <li><strong>EEPROM (Electrically Erasable PROM):</strong> 전기적으로 지울 수 있는 PROM</li>
                </ul>
            </div>
        `,

        'memory-types': `
            <h3>Memory Devices Overview (메모리 장치 개요)</h3>
            <p><strong>Read Only Memory (ROM, 읽기 전용 메모리):</strong> 비휘발성 메모리</p>
            <p><strong>Random Access Memory (RAM, 랜덤 액세스 메모리):</strong> 휘발성 메모리</p>
            
            <div class="tech-note">
                <h4>비휘발성 메모리 (Non-volatile)</h4>
                <ul>
                    <li><strong>ROM:</strong> 공장에서 프로그래밍</li>
                    <li><strong>PROM:</strong> 프로그래밍 가능</li>
                    <li><strong>EPROM:</strong> 프로그래밍 가능하고 지울 수 있음</li>
                    <li><strong>Flash Memory:</strong> 전기적으로 지울 수 있는 비휘발성 메모리</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>휘발성 메모리 (Volatile)</h4>
                <ul>
                    <li><strong>SRAM:</strong> 정적 RAM</li>
                    <li><strong>DRAM:</strong> 동적 RAM</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>신흥 메모리 기술 (Emerging Memory Technologies)</h4>
                <ul>
                    <li><strong>Phase-change Memory (PCM):</strong> 상 변화 메모리</li>
                    <li><strong>STT-RAM:</strong> Spin-Transfer Torque RAM</li>
                    <li><strong>MRAM:</strong> Magnetic RAM</li>
                </ul>
            </div>
        `,

        'memory-comparison': `
            <h3>Memory Comparison (메모리 비교)</h3>
            <p>다양한 메모리 장치의 특성을 비교합니다.</p>
            
            <table>
                <tr>
                    <th>특성</th>
                    <th>SRAM</th>
                    <th>DRAM</th>
                    <th>Flash (NAND)</th>
                    <th>HDD</th>
                </tr>
                <tr>
                    <td>밀도 (F²)</td>
                    <td>140</td>
                    <td>6-12</td>
                    <td>1-4</td>
                    <td>2/3</td>
                </tr>
                <tr>
                    <td>에너지/비트 (pJ)</td>
                    <td>0.0005</td>
                    <td>0.005</td>
                    <td>0.00002</td>
                    <td>5×10³-10⁴</td>
                </tr>
                <tr>
                    <td>읽기 시간 (ns)</td>
                    <td>0.1-0.3</td>
                    <td>10</td>
                    <td>100,000</td>
                    <td>5-8×10⁶</td>
                </tr>
                <tr>
                    <td>쓰기 시간 (ns)</td>
                    <td>0.1-0.3</td>
                    <td>10</td>
                    <td>100,000</td>
                    <td>5-8×10⁶</td>
                </tr>
                <tr>
                    <td>보존 기간</td>
                    <td>전원 공급 시</td>
                    <td>&lt;&lt; 1초</td>
                    <td>수년</td>
                    <td>수년</td>
                </tr>
                <tr>
                    <td>내구성 (사이클)</td>
                    <td>&gt;10¹⁶</td>
                    <td>&gt;10¹⁶</td>
                    <td>10⁴</td>
                    <td>10⁴</td>
                </tr>
            </table>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <ul>
                    <li><strong>SRAM:</strong> 가장 빠르지만 밀도가 낮음</li>
                    <li><strong>DRAM:</strong> 밀도가 높고 가격이 저렴하지만 주기적 갱신 필요</li>
                    <li><strong>Flash:</strong> 비휘발성이지만 쓰기 속도가 느림</li>
                    <li><strong>HDD:</strong> 용량이 크지만 매우 느림</li>
                </ul>
            </div>
        `,

        'eprom': `
            <h3>EPROM (Erasable Programmable ROM)</h3>
            <p><strong>EPROM (Erasable Programmable ROM, 지울 수 있는 프로그래밍 가능 ROM):</strong> 자외선으로 지울 수 있는 비휘발성 메모리</p>
            <p><strong>Non-volatile (비휘발성):</strong> 전원이 꺼져도 데이터가 유지됨</p>
            <p><strong>Floating-gate Transistor (플로팅 게이트 트랜지스터):</strong> EPROM의 기본 저장 셀</p>
            
            <div class="tech-note">
                <h4>EPROM의 특징</h4>
                <ul>
                    <li><strong>프로그래밍:</strong> 높은 전압으로 개별 트랜지스터 프로그래밍</li>
                    <li><strong>지우기:</strong> 강한 자외선에 노출하여 지움</li>
                    <li><strong>접근 시간:</strong> 90ns</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>읽기 동작 (Read Operation)</h4>
                <ol>
                    <li>주소를 주소 버스에 설정</li>
                    <li>Chip Enable (CE) 활성화</li>
                    <li>Output Enable (OE) 활성화</li>
                    <li>데이터 버스에 출력</li>
                </ol>
                <p>가장 간단한 메모리 접근 방식입니다.</p>
            </div>
            
            <div class="exam-point">
                <h4>🚩 타이밍 파라미터</h4>
                <ul>
                    <li><strong>tOFF:</strong> OE 또는 CE 중 먼저 발생하는 것에 대해 지정됨</li>
                    <li><strong>tCE - tOE:</strong> OE를 CE 하강 엣지 후 최대 이 시간만큼 지연 가능</li>
                </ul>
            </div>
        `,

        'sram': `
            <h3>SRAM (Static RAM)</h3>
            <p><strong>SRAM (Static RAM, 정적 RAM):</strong> 플립플롭 기반의 휘발성 메모리</p>
            <p><strong>Chip Select (CS, 칩 선택):</strong> 칩을 활성화하는 신호</p>
            <p><strong>Write Enable (WE, 쓰기 활성화):</strong> 쓰기 동작을 제어하는 신호</p>
            
            <div class="tech-note">
                <h4>SRAM 구조 예시</h4>
                <ul>
                    <li><strong>4 × 1Kbyte 메모리 배열:</strong> 4개의 1KB 배열</li>
                    <li><strong>4 bit 데이터 × 10 bit 주소:</strong> 4비트 데이터, 10비트 주소</li>
                    <li><strong>핀 구성:</strong>
                        <ul>
                            <li>A₀ ~ A₉: 주소 입력</li>
                            <li>CS: 칩 선택</li>
                            <li>WE: 쓰기 활성화</li>
                            <li>I/O₁ ~ I/O₄: 데이터 입출력</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 질문: 메모리 크기와 데이터/주소 버스 폭의 관계는?</h4>
                <p>메모리 크기 = 2^(주소 비트 수) × 데이터 비트 수</p>
                <p>예: 10비트 주소, 4비트 데이터 → 2¹⁰ × 4 = 1024 × 4 = 4Kbit = 1Kbyte</p>
            </div>
            
            <div class="tech-note">
                <h4>읽기 사이클 (Read Cycle)</h4>
                <ol>
                    <li>주소 설정</li>
                    <li>칩 선택 (CS)</li>
                    <li>데이터 출력</li>
                </ol>
            </div>
            
            <div class="tech-note">
                <h4>쓰기 사이클 (Write Cycle)</h4>
                <ol>
                    <li>주소 설정</li>
                    <li>칩 선택 (CS) & 쓰기 활성화 (WE)</li>
                    <li>상승 엣지에서 데이터 입력</li>
                </ol>
            </div>
        `,

        'z80-instruction': `
            <h3>Z80 Instruction Cycle (Z80 명령어 사이클)</h3>
            <p><strong>M1:</strong> Opcode fetch (명령어 코드 가져오기)</p>
            <p><strong>M2:</strong> Memory read (메모리 읽기)</p>
            <p><strong>M3:</strong> Memory write (메모리 쓰기)</p>
            
            <div class="easy-explain">
                <h4>💡 왜 이렇게 구성되었을까?</h4>
                <p>메모리에서 메모리로 데이터를 이동하는 경우를 생각해보세요.</p>
                <ul>
                    <li>M1: 명령어 코드를 가져옴</li>
                    <li>M2: 소스 메모리에서 데이터 읽기</li>
                    <li>M3: 목적지 메모리에 데이터 쓰기</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>M1: Opcode Fetch</h4>
                <ul>
                    <li>PC(Program Counter)가 가리키는 메모리에서 코드 읽기</li>
                    <li>주소, 제어 신호, 데이터가 클럭 신호로 동기화</li>
                    <li>주소가 주어진 후 다음 클럭 상승 엣지에서 데이터 전달</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>지연된 메모리 접근 (Delayed Memory Access)</h4>
                <p>주소가 주어진 후 데이터를 전달할 수 없으면, Wait 신호가 접근 사이클을 유지합니다.</p>
            </div>
            
            <div class="tech-note">
                <h4>쓰기 동작 (Write Operation)</h4>
                <ol>
                    <li>칩 선택</li>
                    <li>주소 버스에 주소 설정</li>
                    <li>다음 클럭 상승 엣지에서 버스에 출력 데이터 설정</li>
                </ol>
            </div>
        `,

        'bus-arbitration': `
            <h3>Bus Arbitration (버스 중재)</h3>
            <p><strong>Bus Arbitration (버스 중재):</strong> 여러 마스터 장치가 버스를 공유할 때의 중재 메커니즘</p>
            <p><strong>Bus Request (버스 요청):</strong> 다른 마스터 장치로부터의 버스 요청</p>
            <p><strong>ACK Signal (응답 신호):</strong> 버스 사용 권한을 부여하는 신호</p>
            <p><strong>High-Z State (하이 임피던스 상태):</strong> 출력이 끊어진 상태 (트라이스테이트)</p>
            
            <div class="tech-note">
                <h4>버스 중재 과정</h4>
                <ol>
                    <li>다른 마스터 장치로부터 버스 요청 (Bus Request)</li>
                    <li>ACK 신호로 응답</li>
                    <li>출력 신호를 High-Z 상태로 설정하여 버스 마스터 변경</li>
                </ol>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>버스를 공유하는 여러 장치가 있을 때, 한 번에 하나의 장치만 버스를 사용할 수 있습니다. 버스 중재는 이를 보장합니다.</p>
            </div>
        `,

        'dram-structure': `
            <h3>DRAM Structure (DRAM 구조)</h3>
            <p><strong>DRAM (Dynamic RAM, 동적 RAM):</strong> 커패시터 기반의 휘발성 메모리</p>
            <p><strong>Capacitor (커패시터):</strong> 전하를 저장하는 소자</p>
            
            <div class="easy-explain">
                <h4>💡 DRAM의 원리</h4>
                <ul>
                    <li>커패시터에 전하를 저장하여 데이터를 표현</li>
                    <li>전하는 시간이 지나면 누출되므로 주기적 갱신(Refresh) 필요</li>
                    <li>SRAM보다 밀도가 높고 가격이 저렴</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>DRAM vs SRAM</h4>
                <ul>
                    <li><strong>SRAM:</strong> 플립플롭 기반, 빠르지만 밀도 낮음</li>
                    <li><strong>DRAM:</strong> 커패시터 기반, 느리지만 밀도 높음</li>
                </ul>
            </div>
        `,

        'dram-access': `
            <h3>DRAM Access (DRAM 접근)</h3>
            <p><strong>RAS (Row Address Strobe, 행 주소 스트로브):</strong> 행 주소를 선택하는 신호</p>
            <p><strong>CAS (Column Address Strobe, 열 주소 스트로브):</strong> 열 주소를 선택하는 신호</p>
            <p><strong>Precharge (프리차지):</strong> 다음 접근을 위해 비트라인을 충전하는 과정</p>
            
            <canvas id="cvs_dram_access"></canvas>
            
            <div class="tech-note">
                <h4>DRAM 접근 과정</h4>
                <ol>
                    <li><strong>Precharge:</strong> 비트라인을 미리 충전</li>
                    <li><strong>Row Access:</strong> RAS로 행 선택 및 활성화</li>
                    <li><strong>Column Access:</strong> CAS로 열 선택</li>
                    <li><strong>Bus Transaction:</strong> 데이터 읽기/쓰기</li>
                </ol>
            </div>
            
            <div class="exam-point">
                <h4>🚩 RAS-CAS 타이밍</h4>
                <p>DRAM 접근은 RAS와 CAS 신호의 타이밍이 중요합니다.</p>
                <ul>
                    <li>RAS가 먼저 활성화되어 행을 선택</li>
                    <li>그 다음 CAS가 활성화되어 열을 선택</li>
                    <li>타이밍이 맞지 않으면 데이터 오류 발생</li>
                </ul>
            </div>
            
            <div class="tab-container">
                <div class="tab-header">
                    <button class="tab-btn active" onclick="window.switchTab('process', this)">접근 과정</button>
                    <button class="tab-btn" onclick="window.switchTab('timing', this)">타이밍</button>
                </div>
                
                <div id="tab-process" class="tab-pane active">
                    <div class="tech-note">
                        <h4>단계별 접근 과정</h4>
                        <ol>
                            <li><strong>Precharge:</strong> 비트라인을 VDD/2로 충전</li>
                            <li><strong>Row Access:</strong> RAS 활성화, 행 선택 및 활성화</li>
                            <li><strong>Column Access:</strong> CAS 활성화, 열 선택</li>
                            <li><strong>Data Transfer:</strong> 데이터 읽기/쓰기</li>
                        </ol>
                    </div>
                </div>
                
                <div id="tab-timing" class="tab-pane">
                    <div class="tech-note">
                        <h4>RAS-CAS 타이밍 다이어그램</h4>
                        <p>RAS와 CAS 신호의 상대적 타이밍이 중요합니다.</p>
                        <ul>
                            <li><strong>tRCD:</strong> RAS to CAS Delay (행 선택 후 열 선택까지의 지연)</li>
                            <li><strong>tCAS:</strong> CAS Latency (열 선택 후 데이터 출력까지의 지연)</li>
                            <li><strong>tRP:</strong> Row Precharge Time (행 프리차지 시간)</li>
                        </ul>
                    </div>
                </div>
            </div>
        `,

        'dram-latency': `
            <h3>DRAM Latency (DRAM 지연 시간)</h3>
            <p><strong>DRAM Latency (DRAM 지연 시간):</strong> 요청부터 데이터 반환까지의 총 시간</p>
            
            <div class="tech-note">
                <h4>DRAM 지연 시간 구성 요소</h4>
                <ol>
                    <li><strong>A: Queue Delay</strong> - 요청이 큐에서 대기하는 시간</li>
                    <li><strong>B: Memory Controller</strong> - 요청이 메모리 컨트롤러로 전송</li>
                    <li><strong>C: Command Conversion</strong> - 트랜잭션이 명령어 시퀀스로 변환</li>
                    <li><strong>D: Command to DRAM</strong> - 명령어가 DRAM으로 전송</li>
                    <li><strong>E: DRAM Access</strong>
                        <ul>
                            <li><strong>E1:</strong> CAS만 필요 (이미 행이 활성화됨)</li>
                            <li><strong>E2:</strong> RAS + CAS 필요</li>
                            <li><strong>E3:</strong> PRE + RAS + CAS 필요 (가장 느림)</li>
                        </ul>
                    </li>
                    <li><strong>F: Return to CPU</strong> - 데이터가 CPU로 반환</li>
                </ol>
            </div>
            
            <div class="math-block">
                DRAM Latency = A + B + C + D + E + F
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>DRAM 지연 시간은 여러 단계의 합입니다. E 단계가 가장 크게 영향을 미치며, 이미 활성화된 행에 접근하는 경우(E1)가 가장 빠릅니다.</p>
            </div>
        `,

        'flash-structure': `
            <h3>Flash Memory Structure (Flash 메모리 구조)</h3>
            <p><strong>Flash Memory (플래시 메모리):</strong> 전기적으로 지울 수 있는 비휘발성 메모리</p>
            <p><strong>NAND Flash:</strong> NAND 게이트 구조를 사용하는 Flash 메모리</p>
            
            <div class="tech-note">
                <h4>K9F1G08U0D 예제 (Samsung 1Gbit NAND Flash)</h4>
                <ul>
                    <li><strong>Memory Cell Array:</strong> (128M + 4M) × 8bit</li>
                    <li><strong>Page Size (페이지 크기):</strong> (2K + 64)Byte</li>
                    <li><strong>Erase Block (지우기 블록):</strong> (128K + 4K)Byte</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>성능 특성</h4>
                <ul>
                    <li><strong>Random Read (랜덤 읽기):</strong> 40μs (최대)</li>
                    <li><strong>Serial Access (순차 접근):</strong> 25ns (최소)</li>
                    <li><strong>Page Program Time (페이지 프로그래밍 시간):</strong> 250μs (일반)</li>
                    <li><strong>Block Erase Time (블록 지우기 시간):</strong> 2ms (일반)</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <ul>
                    <li>Flash는 <strong>페이지 단위</strong>로 읽고 씁니다</li>
                    <li>지우기는 <strong>블록 단위</strong>로 수행됩니다</li>
                    <li>랜덤 읽기보다 순차 읽기가 훨씬 빠릅니다</li>
                </ul>
            </div>
        `,

        'flash-interface': `
            <h3>Flash Interface (Flash 인터페이스)</h3>
            <p><strong>Flash Interface (Flash 인터페이스):</strong> Flash 메모리를 제어하는 인터페이스</p>
            <p><strong>Command Register (명령 레지스터):</strong> Flash에 명령을 전달하는 레지스터</p>
            <p><strong>Command Buffer (명령 버퍼):</strong> 명령 데이터를 저장하는 버퍼</p>
            <p><strong>Status Flag (상태 플래그):</strong> 작업 완료 여부를 나타내는 플래그</p>
            
            <div class="tech-note">
                <h4>Flash 동작 순서: Erase → Program → Read</h4>
                <ol>
                    <li><strong>Erase (지우기):</strong> 블록 단위로 지움</li>
                    <li><strong>Program (프로그래밍):</strong> 페이지 단위로 데이터 쓰기</li>
                    <li><strong>Read (읽기):</strong> 페이지 단위로 데이터 읽기</li>
                </ol>
            </div>
            
            <div class="tech-note">
                <h4>명령 시퀀스</h4>
                <ol>
                    <li><strong>Ignition Command (점화 명령) 전송:</strong> 작업 시작 명령</li>
                    <li><strong>버퍼에 데이터 채우기:</strong> 프로그래밍할 데이터 입력</li>
                    <li><strong>Program Start Command (프로그래밍 시작 명령) 전송:</strong> 실제 쓰기 시작</li>
                    <li><strong>상태 플래그 확인:</strong> 프로그래밍 완료 여부 확인</li>
                    <li><strong>완료 및 다음 명령 준비:</strong> 작업 완료</li>
                </ol>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>Flash는 단순한 읽기/쓰기가 아니라 명령 시퀀스를 통해 제어됩니다. 상태 플래그를 확인하여 작업 완료를 기다려야 합니다.</p>
            </div>
        `,

        'memory-hierarchy': `
            <h3>Memory Hierarchy (메모리 계층 구조)</h3>
            <p><strong>Memory Hierarchy (메모리 계층 구조):</strong> 성능 문제를 논의하기 위한 컴퓨터 아키텍처 설계 개념</p>
            <p><strong>Locality of Reference (참조 지역성):</strong> 최근에 접근한 데이터에 다시 접근할 가능성이 높은 특성</p>
            
            <canvas id="cvs_memory_hierarchy"></canvas>
            
            <div class="easy-explain">
                <h4>💡 메모리 계층 구조의 원리</h4>
                <ul>
                    <li>각 계층은 응답 시간, 복잡도, 용량으로 구분됨</li>
                    <li>일반적으로 상위 계층일수록 작고 빠름</li>
                    <li>하위 계층은 버퍼를 채우고 전송을 활성화하여 대기 시간 제한</li>
                    <li><strong>핵심:</strong> 느린 장치 접근을 피하자!</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>주요 저장 계층</h4>
                <ul>
                    <li><strong>Internal (내부):</strong> 프로세서 레지스터와 캐시</li>
                    <li><strong>Main (메인):</strong> 시스템 RAM과 컨트롤러 카드</li>
                    <li><strong>On-line Mass Storage (온라인 대용량 저장):</strong> 보조 저장장치</li>
                    <li><strong>Off-line Bulk Storage (오프라인 대용량 저장):</strong> 3차 및 오프라인 저장</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 고성능 설계를 위한 고려사항</h4>
                <ul>
                    <li>각 구성 요소의 크기와 기능 고려</li>
                    <li>계층의 각 구성원은 일반적으로 다음 상위 구성원보다 작고 빠름</li>
                    <li>버퍼링과 전송 최적화</li>
                </ul>
            </div>
        `,

        'hierarchy-design': `
            <h3>Hierarchy Design Principles (계층 구조 설계 원칙)</h3>
            <p><strong>High Performance (고성능):</strong> 각 구성 요소의 크기와 기능을 고려한 설계</p>
            
            <div class="tech-note">
                <h4>설계 원칙</h4>
                <ul>
                    <li><strong>크기와 기능 고려:</strong> 각 구성 요소의 특성 파악</li>
                    <li><strong>계층적 구조:</strong> 상위 계층일수록 작고 빠름</li>
                    <li><strong>버퍼링:</strong> 하위 계층이 버퍼를 채우고 신호로 전송 활성화</li>
                    <li><strong>목표:</strong> 느린 장치 접근을 피함</li>
                </ul>
            </div>
            
            <div class="easy-explain">
                <h4>💡 데이터센터의 외침</h4>
                <p>"Avoid to access the slow devices!" (느린 장치 접근을 피하자!)</p>
                <p>이것이 메모리 계층 구조의 핵심 철학입니다.</p>
            </div>
            
            <div class="tech-note">
                <h4>Computer Memory Hierarchy</h4>
                <p>레지스터 → L1 캐시 → L2 캐시 → L3 캐시 → 메인 메모리 → 디스크</p>
                <p>각 계층은 용량이 크고 속도가 느려질수록 가격이 저렴해집니다.</p>
            </div>
        `
    };

    // ============================================
    // 3. Canvas 다이어그램 그리기 함수들
    // ============================================
    
    function drawMemoryInterface() {
        var c = document.getElementById('cvs_memory_interface');
        if (!c) {
            console.warn('Canvas cvs_memory_interface not found');
            return;
        }
        var ctx = c.getContext('2d');
        var w = c.width = c.clientWidth || 600;
        var h = c.height = 280;
        ctx.clearRect(0, 0, w, h);
        ctx.lineWidth = 2;
        ctx.font = "bold 14px sans-serif";
        
        // Processor
        ctx.fillStyle = "#4f46e5";
        ctx.fillRect(50, 50, 150, 80);
        ctx.strokeRect(50, 50, 150, 80);
        ctx.fillStyle = "#fff";
        ctx.fillText("Processor", 90, 85);
        ctx.font = "12px sans-serif";
        ctx.fillText("(CPU)", 100, 105);
        
        // Memory
        ctx.fillStyle = "#10b981";
        ctx.fillRect(300, 50, 150, 80);
        ctx.strokeRect(300, 50, 150, 80);
        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText("Memory", 340, 85);
        ctx.font = "12px sans-serif";
        ctx.fillText("(SRAM/DRAM)", 320, 105);
        
        // Address Bus
        ctx.strokeStyle = "#f43f5e";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(200, 70);
        ctx.lineTo(300, 70);
        ctx.stroke();
        ctx.fillStyle = "#1e293b";
        ctx.font = "12px sans-serif";
        ctx.fillText("Address Bus", 210, 65);
        
        // Data Bus
        ctx.beginPath();
        ctx.moveTo(200, 110);
        ctx.lineTo(300, 110);
        ctx.stroke();
        ctx.fillText("Data Bus", 215, 125);
        
        // Control Signals
        ctx.strokeStyle = "#fbbf24";
        ctx.beginPath();
        ctx.moveTo(200, 90);
        ctx.lineTo(300, 90);
        ctx.stroke();
        ctx.fillStyle = "#1e293b";
        ctx.fillText("Control", 215, 95);
        
        // 설명
        ctx.fillStyle = "#334155";
        ctx.font = "11px sans-serif";
        ctx.fillText("프로세서와 메모리 간 인터페이스", 50, 160);
        ctx.fillText("Address: 주소 지정, Data: 데이터 전송, Control: 제어 신호", 50, 180);
    }
    
    function drawDRAMAccess() {
        var c = document.getElementById('cvs_dram_access');
        if (!c) {
            console.warn('Canvas cvs_dram_access not found');
            return;
        }
        var ctx = c.getContext('2d');
        var w = c.width = c.clientWidth || 600;
        var h = c.height = 320;
        ctx.clearRect(0, 0, w, h);
        ctx.lineWidth = 2;
        ctx.font = "bold 14px sans-serif";
        
        // 단계별 박스
        var steps = [
            {x: 50, y: 40, w: 120, h: 50, text: "1. Precharge", color: "#e0e7ff"},
            {x: 200, y: 40, w: 120, h: 50, text: "2. Row Access", color: "#dbeafe"},
            {x: 350, y: 40, w: 120, h: 50, text: "3. Column Access", color: "#d1fae5"},
            {x: 200, y: 120, w: 120, h: 50, text: "4. Data Transfer", color: "#fef3c7"}
        ];
        
        for (var i = 0; i < steps.length; i++) {
            var s = steps[i];
            ctx.fillStyle = s.color;
            ctx.fillRect(s.x, s.y, s.w, s.h);
            ctx.strokeRect(s.x, s.y, s.w, s.h);
            ctx.fillStyle = "#1e293b";
            ctx.font = "12px sans-serif";
            ctx.fillText(s.text, s.x + 10, s.y + 30);
        }
        
        // 화살표
        ctx.strokeStyle = "#f43f5e";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(170, 65);
        ctx.lineTo(200, 65);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(320, 65);
        ctx.lineTo(350, 65);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(260, 90);
        ctx.lineTo(260, 120);
        ctx.stroke();
        
        // RAS-CAS 타이밍
        ctx.fillStyle = "#334155";
        ctx.font = "bold 12px sans-serif";
        ctx.fillText("RAS-CAS Timing:", 50, 220);
        ctx.font = "11px sans-serif";
        ctx.fillText("RAS 활성화 → 행 선택 → CAS 활성화 → 열 선택 → 데이터 전송", 50, 240);
        
        // 설명
        ctx.fillText("DRAM 접근은 여러 단계를 거칩니다", 50, 280);
        ctx.fillText("각 단계는 특정 타이밍을 요구합니다", 50, 300);
    }
    
    function drawMemoryHierarchy() {
        var c = document.getElementById('cvs_memory_hierarchy');
        if (!c) {
            console.warn('Canvas cvs_memory_hierarchy not found');
            return;
        }
        var ctx = c.getContext('2d');
        var w = c.width = c.clientWidth || 600;
        var h = c.height = 360;
        ctx.clearRect(0, 0, w, h);
        ctx.lineWidth = 2;
        ctx.font = "bold 14px sans-serif";
        
        // 계층 구조 (위에서 아래로)
        var levels = [
            {y: 30, text: "Registers (레지스터)", color: "#4f46e5", size: "가장 빠름, 가장 작음"},
            {y: 80, text: "L1 Cache", color: "#6366f1", size: "매우 빠름"},
            {y: 130, text: "L2 Cache", color: "#818cf8", size: "빠름"},
            {y: 180, text: "L3 Cache", color: "#a5b4fc", size: "보통"},
            {y: 230, text: "Main Memory (DRAM)", color: "#10b981", size: "느림"},
            {y: 280, text: "Disk (HDD/SSD)", color: "#64748b", size: "가장 느림, 가장 큼"}
        ];
        
        for (var i = 0; i < levels.length; i++) {
            var l = levels[i];
            ctx.fillStyle = l.color;
            ctx.fillRect(50, l.y, 500, 40);
            ctx.strokeRect(50, l.y, 500, 40);
            ctx.fillStyle = "#fff";
            ctx.font = "bold 13px sans-serif";
            ctx.fillText(l.text, 60, l.y + 25);
            ctx.font = "11px sans-serif";
            ctx.fillText(l.size, 400, l.y + 25);
        }
        
        // 화살표 (위에서 아래로)
        ctx.strokeStyle = "#f43f5e";
        ctx.lineWidth = 2;
        for (var i = 0; i < levels.length - 1; i++) {
            ctx.beginPath();
            ctx.moveTo(300, levels[i].y + 40);
            ctx.lineTo(300, levels[i + 1].y);
            ctx.stroke();
        }
        
        // 설명
        ctx.fillStyle = "#334155";
        ctx.font = "12px sans-serif";
        ctx.fillText("메모리 계층 구조: 위로 갈수록 빠르고 작고 비쌈", 50, 340);
    }
    
    // 캔버스 그리기 함수 (common.js에서 호출됨)
    function runDrawing(id) {
        if (id === 'memory-interface') {
            setTimeout(function() { drawMemoryInterface(); }, 50);
        } else if (id === 'dram-access') {
            setTimeout(function() { drawDRAMAccess(); }, 50);
        } else if (id === 'memory-hierarchy') {
            setTimeout(function() { drawMemoryHierarchy(); }, 50);
        }
    }
</script>
</body>
</html>

