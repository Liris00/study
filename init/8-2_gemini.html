<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 8-2: Signals & Nonlocal Jumps (Ultimate Edition)</title>
    <link rel="stylesheet" href="./style.css">
</head>
<body>

<div class="sidebar">
    <div class="brand">⚡ Logic Master<br><span style="font-weight:400; font-size:0.9rem; opacity:0.8;">Part II</span></div>
    <div class="menu-label">Chapter 8. Signals</div>
    <div class="nav-item active" onclick="showSection('sec-signal', this)"><span class="nav-icon">📡</span> 1. 시그널 기초</div>
    <div class="nav-item" onclick="showSection('sec-sending', this)"><span class="nav-icon">📨</span> 2. 전송과 수신</div>
    <div class="nav-item" onclick="showSection('sec-handling', this)"><span class="nav-icon">🛡️</span> 3. 안전한 핸들링</div>
    <div class="nav-item" onclick="showSection('sec-concurrency', this)"><span class="nav-icon">🔄</span> 4. 동시성 제어</div>
</div>

<div class="main">
    <div id="sec-signal" class="section-container active">
        <div class="header"><h1>1. 시그널 (Signals)</h1><p>프로세스에게 시스템 이벤트를 알리는 작은 메시지</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('signal-concept')">
                <span class="card-icon">🔔</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>시그널이란?</h3>
                <p>ID(1~30)만 존재하는 초경량 알림 메시지. 예외(Exception)의 소프트웨어 버전.</p>
                <div class="btn-learn">쉬운 설명 보기</div>
            </div>
            <div class="card" onclick="openModal('signal-list')">
                <span class="card-icon">📜</span>
                <div class="tag-container"><span class="tag exam">암기</span></div>
                <h3>주요 시그널 ID</h3>
                <p>SIGINT(2), SIGKILL(9), SIGSEGV(11), SIGCHLD(17) 등 핵심 시그널 정리.</p>
                <div class="btn-learn">리스트 보기 (p.14)</div>
            </div>
        </div>
    </div>

    <div id="sec-sending" class="section-container">
        <div class="header"><h1>2. 전송과 수신 (Lifecycle)</h1><p>Pending과 Blocked 비트 벡터의 동작 원리</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('lifecycle-sim')">
                <span class="card-icon">🚥</span>
                <div class="tag-container"><span class="tag core">Interactive</span></div>
                <h3>시그널 라이프사이클</h3>
                <p>전송(Sending) -> 대기(Pending) -> 수신(Receiving) 과정을 <strong>비트 벡터</strong>로 확인하세요.</p>
                <div class="btn-learn">시뮬레이션 시작 ▶</div>
            </div>
            <div class="card" onclick="openModal('process-group')">
                <span class="card-icon">👨‍👩‍👧‍👦</span>
                <div class="tag-container"><span class="tag logic">구조</span></div>
                <h3>프로세스 그룹 (Process Group)</h3>
                <p>모든 자식에게 한 방에 시그널 보내기. <code>kill -9 -PID</code>의 의미.</p>
                <div class="btn-learn">구조도 보기 (p.19)</div>
            </div>
        </div>
    </div>

    <div id="sec-handling" class="section-container">
        <div class="header"><h1>3. 안전한 핸들링 (Safe Handling)</h1><p>동시성 버그를 피하기 위한 까다로운 규칙들</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('handler-flow')">
                <span class="card-icon">🔀</span>
                <div class="tag-container"><span class="tag logic">흐름도</span></div>
                <h3>핸들러 제어 흐름</h3>
                <p>메인 프로그램과 핸들러는 <strong>동시(Concurrent)</strong>에 실행됩니다.</p>
                <div class="btn-learn">Canvas 흐름도</div>
            </div>
            <div class="card" onclick="openModal('async-safe')">
                <span class="card-icon">⚠️</span>
                <div class="tag-container"><span class="tag exam">주의</span></div>
                <h3>Async-Signal-Safe 함수</h3>
                <p>핸들러 안에서 <code>printf</code>를 쓰면 안 되는 이유와 해결책(SIO).</p>
                <div class="btn-learn">안전 수칙 5계명 (p.35)</div>
            </div>
        </div>
    </div>

    <div id="sec-concurrency" class="section-container">
        <div class="header"><h1>4. 동시성 제어 (Concurrency)</h1><p>Race Condition 해결과 올바른 대기 방법</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('race-condition')">
                <span class="card-icon">🏁</span>
                <div class="tag-container"><span class="tag exam">★심화</span></div>
                <h3>경쟁 상태 (Race Condition)</h3>
                <p>부모가 <code>addjob</code> 하기 전에 자식이 죽어서 <code>deletejob</code>을 먼저 부르면?</p>
                <div class="btn-learn">버그 코드 분석</div>
            </div>
            <div class="card" onclick="openModal('sigsuspend')">
                <span class="card-icon">💤</span>
                <div class="tag-container"><span class="tag logic">최적화</span></div>
                <h3>Sigsuspend (Atomic Wait)</h3>
                <p><code>pause()</code>와 <code>sleep()</code>의 문제를 해결하는 원자적 대기 함수.</p>
                <div class="btn-learn">코드 비교 (p.47)</div>
            </div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="modalOverlay" onclick="window.closeModal()">
    <div class="modal-content" onclick="event.stopPropagation()">
        <div class="modal-header">
            <div class="modal-title" id="modalTitle">제목</div>
            <button class="close-btn" onclick="window.closeModal()">✕</button>
        </div>
        <div class="modal-body" id="modalBody">내용</div>
    </div>
</div>

<script src="./common.js"></script>

<script>
    // --- 1. 모달 제목 정의 ---
    window.modalTitles = {
        'signal-concept': '시그널(Signal)의 개념',
        'signal-list': '반드시 외워야 할 주요 시그널',
        'lifecycle-sim': '시그널 라이프사이클 시뮬레이션',
        'process-group': '프로세스 그룹과 전송',
        'handler-flow': '시그널 핸들러의 논리적 흐름',
        'async-safe': '핸들러 작성 안전 수칙 (G0~G5)',
        'race-condition': 'Race Condition 버그 분석',
        'sigsuspend': 'sigsuspend를 이용한 안전한 대기'
    };

    // --- 2. 콘텐츠 데이터 ---
    window.contents = {
        'signal-concept': `
            <h3>시그널(Signal)이란?</h3>
            <div class="easy-explain">
                <h4>📨 문자 메시지 비유</h4>
                <ul>
                    <li><strong>내용 없음:</strong> 시그널은 "몇 번(ID)"인지만 전달합니다. "야!" 하고 부르는 것과 같습니다.</li>
                    <li><strong>비동기적:</strong> 언제 도착할지 모릅니다. 밥 먹다가도 문자가 오면 확인해야 합니다.</li>
                    <li><strong>커널 개입:</strong> 모든 시그널은 커널을 거쳐서 전달됩니다.</li>
                </ul>
            </div>
            <p>시스템 이벤트를 프로세스에게 알리는 작은 메시지입니다. 하드웨어 예외(Interrupt)의 소프트웨어적 형태라고 볼 수 있습니다.</p>
        `,
        'signal-list': `
            <h3>주요 시그널 ID (Linux)</h3>
            <table>
                <tr><th>ID</th><th>이름</th><th>기본 동작</th><th>이벤트</th></tr>
                <tr><td>2</td><td><strong>SIGINT</strong></td><td>종료</td><td>Ctrl+C 입력 (키보드 인터럽트)</td></tr>
                <tr><td>9</td><td><strong>SIGKILL</strong></td><td>종료</td><td>강제 종료 (무시/차단 불가)</td></tr>
                <tr><td>11</td><td><strong>SIGSEGV</strong></td><td>코어 덤프</td><td>잘못된 메모리 접근 (Segfault)</td></tr>
                <tr><td>17</td><td><strong>SIGCHLD</strong></td><td>무시</td><td>자식 프로세스가 중지/종료됨</td></tr>
            </table>
            <div class="exam-point">
                <h4>🚩 시험 포인트</h4>
                <p><strong>SIGKILL(9)</strong>과 <strong>SIGSTOP(19)</strong>은 사용자가 절대 <strong>무시하거나(Ignore) 잡을(Catch) 수 없습니다.</strong> (관리자의 권한)</p>
            </div>
        `,
        'lifecycle-sim': `
            <h3>시그널 처리 과정 (Pending & Blocked)</h3>
            <p>시그널은 큐(Queue)에 쌓이지 않습니다! <strong>비트 벡터(Bit Vector)</strong>로 관리됩니다.</p>
            
            <div class="sim-box">
                <div style="display:flex; justify-content:center; gap:20px; margin-bottom:20px;">
                    <div class="cache-slot" id="bit-pending" style="width:100px;">Pending: 0</div>
                    <div class="cache-slot" id="bit-blocked" style="width:100px; border-color:#64748b; color:#64748b;">Blocked: 0</div>
                </div>
                <div class="sim-log" id="sim-log">👇 버튼을 눌러 시그널을 보내보세요.</div>
                <div class="sim-controls">
                    <button onclick="window.nextSignalStep()">단계별 실행 ▶</button>
                </div>
            </div>
            
            <ul>
                <li><strong>Pending:</strong> 보냈지만 아직 처리되지 않음 (도착 대기).</li>
                <li><strong>Blocked:</strong> 프로그래머가 "지금은 받지 마"라고 막아둠.</li>
                <li><strong>수신 조건:</strong> <code>Pending & ~Blocked</code> 비트가 1일 때 핸들러 실행.</li>
            </ul>
        `,
        'handler-flow': `
            <h3>시그널 핸들러의 제어 흐름</h3>
            <p>핸들러는 별도의 프로세스가 아니라, <strong>같은 프로세스 내의 다른 흐름(Concurrent Flow)</strong>입니다.</p>
            <canvas id="cvs_handler"></canvas>
            <div class="easy-explain">
                <h4>🔄 인터럽트와 유사</h4>
                <p>메인 코드가 실행되다가 시그널이 오면 -> <strong>커널 모드</strong>로 진입 -> <strong>유저 모드 핸들러</strong> 실행 -> 다시 <strong>커널</strong> -> <strong>메인 코드</strong> 복귀.</p>
            </div>
        `,
        'async-safe': `
            <h3>안전한 핸들러 작성 가이드 (G0~G5)</h3>
            <div class="tech-note">
                <h4>⚠️ printf는 왜 위험한가?</h4>
                <p><code>printf</code>는 락(Lock)을 사용합니다. 메인 함수가 <code>printf</code>를 쓰다가 락을 걸었는데, 핸들러가 끼어들어서 또 <code>printf</code>를 호출하면 <strong>데드락(Deadlock)</strong>에 걸릴 수 있습니다.</p>
            </div>
            <ul>
                <li><strong>G1:</strong> Async-Signal-Safe 함수만 써라. (<code>write</code>, <code>_exit</code> 등. <code>printf</code>, <code>malloc</code> 금지!)</li>
                <li><strong>G2:</strong> <code>errno</code>를 저장하고 복원해라.</li>
                <li><strong>G3:</strong> 공유 변수 접근 시 시그널을 잠시 막아라(Block).</li>
                <li><strong>G4:</strong> 전역 변수는 <code>volatile</code>로 선언해라.</li>
                <li><strong>G5:</strong> <code>volatile sig_atomic_t</code> 플래그를 사용해라.</li>
            </ul>
        `,
        'race-condition': `
            <h3>Race Condition (경쟁 상태) 분석</h3>
            <div class="tab-container">
                <div class="tab-header">
                    <button class="tab-btn active" onclick="window.switchTab('bug', this)">버그 코드</button>
                    <button class="tab-btn" onclick="window.switchTab('fix', this)">해결 코드</button>
                </div>
                
                <div id="tab-bug" class="tab-pane active">
                    <pre><code><span class="code-function">fork</span>();
<span class="code-comment">// 문제: 자식이 여기서 엄청 빨리 죽어버린다면?</span>
<span class="code-comment">// SIGCHLD 핸들러가 돌면서 deletejob()을 호출함.</span>
<span class="code-comment">// 하지만 addjob()은 아직 실행도 안 됨!</span>
<span class="code-function">addjob</span>(pid); <span class="code-comment">// 존재하지 않는 job을 추가하게 됨.</span></code></pre>
                    <p class="exam-point">부모가 <code>addjob</code>을 하기도 전에 자식이 죽어서 <code>deletejob</code>이 먼저 실행되는 상황입니다.</p>
                </div>
                
                <div id="tab-fix" class="tab-pane">
                    <pre><code><span class="code-function">sigprocmask</span>(SIG_BLOCK, ...); <span class="code-comment">// 1. 시그널 차단</span>
<span class="code-function">fork</span>();
<span class="code-function">addjob</span>(pid); <span class="code-comment">// 2. 안전하게 추가</span>
<span class="code-function">sigprocmask</span>(SIG_UNBLOCK, ...); <span class="code-comment">// 3. 차단 해제</span>
<span class="code-comment">// 이제 시그널이 와서 deletejob이 실행되어도 안전함.</span></code></pre>
                </div>
            </div>
        `,
        'sigsuspend': `
            <h3>명시적 대기: sigsuspend</h3>
            <p>시그널이 올 때까지 기다리고 싶을 때, 어떻게 해야 할까요?</p>
            
            <table>
                <tr><th>방법</th><th>코드</th><th>문제점</th></tr>
                <tr><td>Busy Wait</td><td><code>while(!pid);</code></td><td>CPU 낭비가 심함.</td></tr>
                <tr><td>Pause</td><td><code>pause();</code></td><td><strong>Race Condition!</strong> pause 전에 시그널이 오면 영원히 잠듦.</td></tr>
                <tr><td><strong>Sigsuspend</strong></td><td><code>sigsuspend(&mask);</code></td><td><strong>Atomic(원자적)</strong> 실행. 잠들기 직전에 Unblock을 동시에 수행.</td></tr>
            </table>
            <div class="math-block">
                sigsuspend = Atomic( Unblock + Pause )
            </div>
        `
    };

    // --- 3. 챕터 전용 기능 (시뮬레이션 & 캔버스) ---

    // 시그널 라이프사이클 시뮬레이션
    window.nextSignalStep = function() {
        var pSlot = document.getElementById('bit-pending');
        var bSlot = document.getElementById('bit-blocked');
        var log = document.getElementById('sim-log');
        
        // 단계별 로직
        if (window.simStep === 0) {
            log.innerHTML = "1. <strong>Block:</strong> 중요 작업 중이라 시그널 수신을 막습니다.";
            bSlot.style.borderColor = "var(--accent)";
            bSlot.style.color = "var(--accent)";
            bSlot.innerText = "Blocked: 1";
            window.simStep++;
        } else if (window.simStep === 1) {
            log.innerHTML = "2. <strong>Send:</strong> 시그널 도착! 하지만 Block 상태라 대기(Pending)합니다.";
            pSlot.className = "cache-slot filled";
            pSlot.innerText = "Pending: 1";
            window.simStep++;
        } else if (window.simStep === 2) {
            log.innerHTML = "3. <strong>도착 (Ignored):</strong> 또 시그널이 와도 큐가 없어서 <strong>버려집니다.</strong> (Pending 1 유지)";
            pSlot.classList.add("conflict"); // 흔들림 효과
            setTimeout(() => pSlot.classList.remove("conflict"), 500);
            window.simStep++;
        } else if (window.simStep === 3) {
            log.innerHTML = "4. <strong>Unblock:</strong> 차단 해제! 이제 Pending된 시그널을 처리(Receive)합니다.";
            bSlot.style.borderColor = "#cbd5e1";
            bSlot.style.color = "#cbd5e1";
            bSlot.innerText = "Blocked: 0";
            
            // 처리 효과
            pSlot.className = "cache-slot";
            pSlot.innerText = "Pending: 0";
            pSlot.style.backgroundColor = "var(--success-bg)";
            pSlot.style.borderColor = "var(--success)";
            pSlot.innerHTML = "Received! 🎉";
            window.simStep++;
        } else {
            // 리셋
            pSlot.style.backgroundColor = "#f8fafc";
            pSlot.style.borderColor = "#cbd5e1";
            pSlot.innerHTML = "Pending: 0";
            log.innerText = "다시 시작하려면 버튼을 누르세요.";
            window.simStep = 0;
        }
    };

    // 캔버스 그리기 (common.js에서 호출)
    window.runCanvasDrawing = function(id) {
        if (id === 'handler-flow') drawHandlerFlow();
    };

    function drawHandlerFlow() {
        var c = document.getElementById('cvs_handler'); if(!c) return;
        var ctx = c.getContext('2d');
        var w = c.width = c.clientWidth; var h = c.height = 240;
        ctx.clearRect(0,0,w,h); ctx.lineWidth=2; ctx.font="bold 14px sans-serif";

        // 구획 나누기 (User vs Kernel)
        ctx.fillStyle = "#f1f5f9"; ctx.fillRect(0, 0, w/2, h);
        ctx.fillStyle = "#e0e7ff"; ctx.fillRect(w/2, 0, w/2, h);
        ctx.fillStyle = "#64748b"; ctx.fillText("User Mode", 20, 20); ctx.fillText("Kernel Mode", w/2 + 20, 20);
        ctx.strokeStyle = "#cbd5e1"; ctx.beginPath(); ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); ctx.stroke();

        // Flow Lines
        ctx.strokeStyle = "#334155"; ctx.lineWidth = 3;
        
        // 1. Main -> Kernel (Interrupt)
        ctx.beginPath(); ctx.moveTo(40, 50); ctx.lineTo(w/2 + 40, 70); ctx.stroke();
        drawArrowHead(ctx, w/2 + 40, 70);
        ctx.fillStyle = "#334155"; ctx.fillText("(1) Interrupt", w/2-40, 55);

        // 2. Kernel -> Handler (Signal)
        ctx.beginPath(); ctx.moveTo(w/2 + 40, 100); ctx.lineTo(40, 120); ctx.stroke();
        drawArrowHead(ctx, 40, 120);
        ctx.fillText("(2) Signal", w/2-60, 105);

        // Handler Box
        ctx.fillStyle = "#fff"; ctx.fillRect(20, 120, 100, 40); 
        ctx.strokeRect(20, 120, 100, 40);
        ctx.fillStyle = "#4f46e5"; ctx.fillText("Handler()", 35, 145);

        // 3. Handler -> Kernel (Sigreturn)
        ctx.beginPath(); ctx.moveTo(40, 160); ctx.lineTo(w/2 + 40, 180); ctx.stroke();
        drawArrowHead(ctx, w/2 + 40, 180);
        ctx.fillStyle = "#334155"; ctx.fillText("(3) Return", w/2-40, 165);

        // 4. Kernel -> Main (Resume)
        ctx.beginPath(); ctx.moveTo(w/2 + 40, 210); ctx.lineTo(40, 230); ctx.stroke();
        drawArrowHead(ctx, 40, 230);
        ctx.fillText("(4) Resume", w/2-60, 215);
    }

    function drawArrowHead(ctx, x, y) {
        ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
    }
</script>
</body>
</html>