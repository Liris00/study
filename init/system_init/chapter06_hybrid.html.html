<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 6: Memory Hierarchy (Hybrid Edition)</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Univ AI 스타일의 친절한 설명 박스 추가 */
        .easy-explain {
            background-color: #f0fdf4;
            border-left: 5px solid #22c55e;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .easy-explain h4 {
            color: #15803d;
            margin-top: 0;
        }
        .simulation-step {
            background-color: #f1f5f9;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            font-family: monospace;
        }
    </style>
</head>
<body>

<div class="sidebar">
    <div class="brand">⚡ Logic Master<br><span style="font-size:0.8rem; color:#94a3b8; font-weight:400;">Hybrid Edition</span></div>
    <div class="menu-label">Chapter 6. Memory Hierarchy</div>
    <div class="nav-item active" onclick="showSection('sec-basic', this)"><span class="nav-icon">📚</span> 1. 캐시의 기본 원리</div>
    <div class="nav-item" onclick="showSection('sec-mapping', this)"><span class="nav-icon">🗺️</span> 2. 매핑과 동작</div>
    <div class="nav-item" onclick="showSection('sec-perf', this)"><span class="nav-icon">📊</span> 3. 성능과 정책</div>
    <div class="nav-item" onclick="showSection('sec-opt', this)"><span class="nav-icon">🚀</span> 4. 최적화 (Blocking)</div>
</div>

<div class="main">
    <div id="sec-basic" class="section-container active">
        <div class="header"><h1>1. 캐시 메모리 개요</h1><p>도서관 비유를 통한 계층 구조 이해</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('cache-concept')">
                <span class="card-icon">🏰</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>캐시란 무엇인가?</h3>
                <p>CPU와 메인 메모리 사이의 속도 차이를 줄여주는 고속 창고.</p>
                <div class="btn-learn">쉬운 설명 보기</div>
            </div>
            <div class="card" onclick="openModal('cache-org')">
                <span class="card-icon">🗂️</span>
                <div class="tag-container"><span class="tag exam">구조</span></div>
                <h3>S, E, B 구조</h3>
                <p>Set, Line, Block으로 구성된 캐시의 주소 체계.</p>
                <div class="btn-learn">상세 구조 (p.4)</div>
            </div>
        </div>
    </div>

    <div id="sec-mapping" class="section-container">
        <div class="header"><h1>2. 매핑 방식과 시뮬레이션</h1><p>데이터를 찾는 방법과 충돌의 이해</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('direct-mapped')">
                <span class="card-icon">📍</span>
                <div class="tag-container"><span class="tag core">기초</span></div>
                <h3>Direct Mapped (E=1)</h3>
                <p>한 주소는 오직 한 곳에만! 간단하지만 충돌이 잦은 구조.</p>
                <div class="btn-learn">충돌 시뮬레이션 (p.9)</div>
            </div>
            <div class="card" onclick="openModal('set-associative')">
                <span class="card-icon">🤝</span>
                <div class="tag-container"><span class="tag exam">빈출</span></div>
                <h3>Set Associative (E>1)</h3>
                <p>유연성을 더해 충돌을 줄이는 방식. (2-way, 4-way...)</p>
                <div class="btn-learn">동작 원리 (p.11)</div>
            </div>
        </div>
    </div>

    <div id="sec-perf" class="section-container">
        <div class="header"><h1>3. 쓰기 정책 & 메모리 마운틴</h1><p>데이터 일관성과 지역성(Locality) 시각화</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('write-policy')">
                <span class="card-icon">✍️</span>
                <div class="tag-container"><span class="tag logic">정책</span></div>
                <h3>Write Policy</h3>
                <p>Write-Through vs Write-Back. 언제 메모리에 쓸 것인가?</p>
                <div class="btn-learn">장단점 비교 (p.16)</div>
            </div>
            <div class="card" onclick="openModal('mountain')">
                <span class="card-icon">⛰️</span>
                <div class="tag-container"><span class="tag exam">그래프</span></div>
                <h3>The Memory Mountain</h3>
                <p>Stride(공간)와 Size(시간)에 따른 성능 변화 그래프 해석.</p>
                <div class="btn-learn">그래프 해석 (p.25)</div>
            </div>
        </div>
    </div>

    <div id="sec-opt" class="section-container">
        <div class="header"><h1>4. 캐시 친화적 코드 & 블로킹</h1><p>프로그래머가 할 수 있는 최적화 기법</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('loop-order')">
                <span class="card-icon">🔄</span>
                <div class="tag-container"><span class="tag logic">코딩</span></div>
                <h3>Loop Reordering</h3>
                <p>ijk vs kij. 루프 순서만 바꿔도 속도가 빨라진다?</p>
                <div class="btn-learn">미스율 비교 (p.37)</div>
            </div>
            <div class="card" onclick="openModal('blocking')">
                <span class="card-icon">🧱</span>
                <div class="tag-container"><span class="tag exam">★심화</span></div>
                <h3>Blocking (Tiling)</h3>
                <p>큰 행렬을 작은 블록으로 쪼개서 시간 지역성을 극대화하는 기술.</p>
                <div class="btn-learn">원리 및 도식 (p.43)</div>
            </div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="modalOverlay" onclick="closeModal()">
    <div class="modal-content" onclick="event.stopPropagation()">
        <div class="modal-header">
            <div class="modal-title" id="modalTitle"></div>
            <button class="close-btn" onclick="closeModal()">✕</button>
        </div>
        <div class="modal-body" id="modalBody"></div>
    </div>
</div>

<script src="common.js"></script>
<script>
    // [필수] 페이지 로드 시 초기 화면 설정 (Blank Screen 방지)
    function initializePage() {
        // 모든 섹션 숨기기
        document.querySelectorAll('.section-container').forEach(el => el.classList.remove('active'));
        
        // 첫 번째 섹션 표시
        const firstSection = document.getElementById('sec-basic');
        if (firstSection) {
            firstSection.classList.add('active');
        }
        
        // 첫 번째 네비게이션 활성화
        document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
        const firstNav = document.querySelector('.nav-item');
        if (firstNav) {
            firstNav.classList.add('active');
        }
    }
    
    // DOMContentLoaded와 즉시 실행 모두 처리
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializePage);
    } else {
        // 이미 로드된 경우 즉시 실행
        initializePage();
    }

    const modalTitles = {
        'cache-concept': '캐시 메모리란?',
        'cache-org': '캐시의 주소 구조 (S, E, B)',
        'direct-mapped': 'Direct Mapped Cache 시뮬레이션',
        'set-associative': 'Set Associative Cache 동작',
        'write-policy': '쓰기 정책 (Write Policy)',
        'mountain': '메모리 마운틴 (Memory Mountain)',
        'loop-order': '루프 순서와 공간 지역성',
        'blocking': '블로킹 (Blocking) 기법'
    };

    // --- 하이브리드 콘텐츠 데이터 ---
    const contents = {
        'cache-concept': `
            <h3>캐시 메모리 개요</h3>
            <div class="easy-explain">
                <h4>🎓 Univ AI의 쉬운 설명: 호텔 금고 비유</h4>
                <p>Intel Core i7의 캐시 계층을 호텔에 비유해볼까요?</p>
                <ul>
                    <li><strong>L1 캐시 (개인 금고):</strong> 방 안에 있어서 가장 빠르지만 작습니다. (4 cycle)</li>
                    <li><strong>L2 캐시 (방 안의 옷장):</strong> L1보다 크지만 조금 더 걸립니다. (11 cycle)</li>
                    <li><strong>L3 캐시 (호텔 로비 창고):</strong> 모든 투숙객(코어)이 공유하며 가장 큽니다. (30-40 cycle)</li>
                    <li><strong>메인 메모리 (집):</strong> 호텔 밖 멀리 있는 집입니다. 갖다 오려면 한참 걸립니다. (100+ cycle)</li>
                </ul>
            </div>
            <p>CPU는 데이터를 찾을 때 <strong>L1 → L2 → L3 → 메모리</strong> 순서로 뒤집니다. 가까운 곳에서 찾을수록(Hit) 성능이 좋습니다.</p>
        `,

        'cache-org': `
            <h3>캐시 주소 구조 (S, E, B)</h3>
            <div class="easy-explain">
                <h4>📚 도서관 비유</h4>
                <ul>
                    <li><strong>Set (S):</strong> 도서관의 <strong>'책장 번호'</strong>입니다. 주소를 보고 몇 번 책장으로 갈지 정합니다.</li>
                    <li><strong>Line (E):</strong> 책장 한 칸에 꽂을 수 있는 <strong>'줄의 개수'</strong>입니다.</li>
                    <li><strong>Block (B):</strong> 한 번에 가져오는 <strong>'책 묶음'</strong>의 크기입니다.</li>
                </ul>
            </div>
            <div class="math-block">
                Address = Tag | Set Index | Block Offset
            </div>
            <ul>
                <li><strong>Set Index:</strong> 어느 세트로 갈지 결정</li>
                <li><strong>Tag:</strong> 그 세트 안에 내가 찾는 데이터가 맞는지 확인 (ID 카드 역할)</li>
                <li><strong>Block Offset:</strong> 가져온 데이터 블록 내에서 몇 번째 바이트인지</li>
            </ul>
        `,

        'direct-mapped': `
            <h3>Direct Mapped Cache (E=1)</h3>
            <p>각 메모리 주소가 캐시의 <strong>정해진 딱 한 곳</strong>에만 들어갈 수 있는 구조입니다.</p>
            
            <div class="exam-point">
                <h4>🚩 충돌 미스 (Conflict Miss) 시뮬레이션</h4>
                <p>주소 0번과 8번이 같은 Set 0을 쓴다고 가정해봅시다.</p>
                <div class="simulation-step">1. CPU: 주소 0 요청 -> Miss! (메모리에서 가져와 Set 0에 저장)</div>
                <div class="simulation-step">2. CPU: 주소 8 요청 -> Miss! (Set 0에 있는 주소 0을 쫓아내고 주소 8 저장)</div>
                <div class="simulation-step">3. CPU: 주소 0 재요청 -> Miss! (아까 쫓아냈으므로 다시 가져와야 함)</div>
                <p><strong>결론:</strong> 자리는 하나인데 손님 둘이 번갈아 오면 계속 쫓아내다가 볼일 다 봅니다.</p>
            </div>
        `,

        'set-associative': `
            <h3>E-way Set Associative Cache</h3>
            <p>Direct Mapped의 단점을 해결하기 위해, 한 Set에 <strong>E개의 자리(Line)</strong>를 마련했습니다.</p>
            
            <div class="easy-explain">
                <h4>💡 유연한 저장소</h4>
                <p>마치 도서관 책장(Set) 한 칸에 책을 꽂을 자리가 2개(2-way) 있는 것과 같습니다. <br>
                이미 한 자리가 찼더라도, 옆자리가 비어있으면 기존 책을 버리지 않고 새 책을 꽂을 수 있습니다. 충돌이 훨씬 줄어들죠!</p>
            </div>

            <canvas id="cvs_assoc"></canvas>
            
            <ul>
                <li><strong>검색:</strong> 해당 Set에 있는 E개의 Tag를 <strong>동시에 비교</strong>합니다.</li>
                <li><strong>교체 정책:</strong> 꽉 찼을 때 누구를 버릴까요? 보통 <strong>LRU (가장 오랫동안 안 쓴 것)</strong>를 버립니다.</li>
            </ul>
        `,

        'write-policy': `
            <h3>쓰기 정책 (Write Policy)</h3>
            <p>캐시의 내용이 바뀌었을 때, 메인 메모리에는 언제 반영할까요?</p>

            <table>
                <tr>
                    <th>방식</th>
                    <th>설명</th>
                    <th>장점/단점</th>
                </tr>
                <tr>
                    <td><strong>Write-Through</strong></td>
                    <td>캐시와 메모리에 <strong>동시에</strong> 씁니다.</td>
                    <td>데이터가 안전하지만, 메모리 속도가 느려서 <strong>전체 성능이 저하</strong>됩니다.</td>
                </tr>
                <tr>
                    <td><strong>Write-Back</strong></td>
                    <td><strong>캐시에만</strong> 쓰고, 쫓겨날 때 메모리에 씁니다.</td>
                    <td><strong>빠르지만</strong>, 'Dirty Bit' 관리가 필요하고 설계가 복잡합니다.</td>
                </tr>
            </table>

            <div class="tech-note">
                <h4>Write Miss 정책</h4>
                <ul>
                    <li><strong>Write Allocate:</strong> 메모리에서 데이터를 캐시로 가져온 뒤 씁니다. (Write-Back과 짝꿍)</li>
                    <li><strong>No-Write Allocate:</strong> 캐시를 건너뛰고 메모리에 바로 씁니다. (Write-Through와 짝꿍)</li>
                </ul>
            </div>
        `,

        'mountain': `
            <h3>메모리 마운틴 (The Memory Mountain)</h3>
            <p>프로그램의 지역성(Locality)에 따른 성능을 산맥처럼 시각화한 것입니다.</p>
            
            <ul>
                <li><strong>Ridges (능선) - 시간 지역성:</strong> 데이터 크기(Working Set)가 작아서 L1, L2 캐시 안에 쏙 들어갈수록 읽기 속도(높이)가 높습니다.</li>
                <li><strong>Slopes (비탈) - 공간 지역성:</strong> Stride(보폭)가 작을수록(순차 접근) 성능이 좋습니다. Stride가 커지면 비탈길을 따라 성능이 뚝 떨어집니다.</li>
            </ul>
            <p><strong>핵심:</strong> 평평한 고원(L1, L2 영역)에 머무르도록 코딩해야 합니다.</p>
        `,

        'loop-order': `
            <h3>행렬 곱셈 루프 순서 최적화</h3>
            <div class="easy-explain">
                <h4>🍳 요리사 비유: 재료 준비</h4>
                <p>배열은 메모리에 가로로 쭉 나열되어 있습니다(Row-major). <br>
                순서대로 읽는 것(Stride-1)은 재료를 순서대로 집는 것이고, 건너뛰며 읽는 것은 재료 하나 집고 저 멀리 가서 다른 재료 집어오는 격입니다.</p>
            </div>

            <table>
                <tr>
                    <th>코드 순서</th>
                    <th>접근 패턴</th>
                    <th>Misses/Iter</th>
                    <th>성능</th>
                </tr>
                <tr>
                    <td><code>kij</code>, <code>ikj</code></td>
                    <td><strong>Sequential (Stride-1)</strong></td>
                    <td>0.5 (최소)</td>
                    <td><strong>Best 🚀</strong></td>
                </tr>
                <tr>
                    <td><code>ijk</code>, <code>jik</code></td>
                    <td>Mixed</td>
                    <td>1.25</td>
                    <td>Middle</td>
                </tr>
                <tr>
                    <td><code>jki</code>, <code>kji</code></td>
                    <td>Strided (점프)</td>
                    <td>2.0 (최대)</td>
                    <td>Worst 🐢</td>
                </tr>
            </table>
        `,

        'blocking': `
            <h3>블로킹 (Blocking) 기법</h3>
            <p>행렬이 너무 커서 캐시에 다 안 들어간다면? <strong>작은 블록(Sub-matrix)</strong>으로 쪼개서 처리합시다.</p>

            <div class="easy-explain">
                <h4>📦 이삿짐 비유</h4>
                <p>큰 짐을 한 번에 다 옮기려다간 지쳐서 다 떨어뜨립니다. <br>
                대신 <strong>작은 상자(Block)</strong>에 나눠 담아서 옮기면, 한 상자 안의 물건들은 내 손 닿는 곳(캐시)에 두고 빠르게 정리할 수 있죠.</p>
            </div>

            <canvas id="cvs_blocking"></canvas>

            <div class="math-block">
                Miss Rate (Blocking) = N³ / (4 * B)<br>
                (B: 블록 크기)
            </div>
            <p>블록 크기 B를 키울수록 미스율은 반비례해서 줄어듭니다. (단, 캐시 크기보다는 작아야 함)</p>
        `
    };

    // --- 캔버스 드로잉 함수 ---
    function runDrawing(id) {
        if (id === 'set-associative') drawAssociative();
        else if (id === 'blocking') drawBlocking();
    }

    function drawAssociative() {
        const c = document.getElementById('cvs_assoc'); if(!c) return;
        const ctx = c.getContext('2d');
        const w = c.width = c.clientWidth || 600; const h = c.height = 180;
        ctx.clearRect(0,0,w,h); ctx.lineWidth=2; ctx.font="14px sans-serif";

        // Set Box
        ctx.strokeRect(50, 40, 500, 100);
        ctx.fillStyle = "#1e293b"; ctx.fillText("Set i (책장 한 칸)", 20, 95);

        // Line 0
        ctx.fillStyle = "#eff6ff"; ctx.fillRect(60, 50, 200, 80);
        ctx.strokeRect(60, 50, 200, 80);
        ctx.fillStyle = "#1e293b"; ctx.fillText("Way 0 (빈자리 1)", 110, 95);
        ctx.strokeRect(70, 60, 40, 60); ctx.fillText("Tag", 75, 95);

        // Line 1
        ctx.fillStyle = "#eff6ff"; ctx.fillRect(340, 50, 200, 80);
        ctx.strokeRect(340, 50, 200, 80);
        ctx.fillStyle = "#1e293b"; ctx.fillText("Way 1 (빈자리 2)", 390, 95);
        ctx.strokeRect(350, 60, 40, 60); ctx.fillText("Tag", 355, 95);

        // Comparison
        ctx.fillStyle = "#f43f5e"; ctx.fillText("동시에 Tag 비교!", 250, 160);
        ctx.beginPath(); ctx.moveTo(300, 25); 
        ctx.lineTo(90, 25); ctx.lineTo(90, 60);
        ctx.moveTo(300, 25);
        ctx.lineTo(370, 25); ctx.lineTo(370, 60);
        ctx.stroke();
        ctx.fillStyle = "#1e293b"; ctx.fillText("Search Tag", 265, 20);
    }

    function drawBlocking() {
        const c = document.getElementById('cvs_blocking'); if(!c) return;
        const ctx = c.getContext('2d');
        const w = c.width = c.clientWidth || 600; const h = c.height = 180;
        ctx.clearRect(0,0,w,h); ctx.lineWidth=2; ctx.font="12px sans-serif";

        // Matrix A
        ctx.strokeRect(50, 30, 100, 100); ctx.fillText("Matrix A", 70, 20);
        ctx.fillStyle = "#cbd5e1"; ctx.fillRect(50, 30, 100, 100);
        // Block in A
        ctx.fillStyle = "#f43f5e"; ctx.fillRect(50, 30, 30, 30); ctx.strokeRect(50, 30, 30, 30);
        
        ctx.fillStyle = "#1e293b"; ctx.fillText("x", 170, 80);

        // Matrix B
        ctx.strokeRect(200, 30, 100, 100); ctx.fillText("Matrix B", 220, 20);
        ctx.fillStyle = "#cbd5e1"; ctx.fillRect(200, 30, 100, 100);
        // Block in B
        ctx.fillStyle = "#4f46e5"; ctx.fillRect(200, 30, 30, 30); ctx.strokeRect(200, 30, 30, 30);

        // Explanation
        ctx.fillStyle = "#334155";
        ctx.fillText("작은 B x B 블록만 캐시에 로드!", 100, 150);
        ctx.fillText("=> 쫓겨나지 않고 계속 재사용됨", 100, 165);

        // Arrows
        ctx.strokeStyle = "#64748b";
        ctx.beginPath(); ctx.moveTo(65, 60); ctx.lineTo(65, 130); ctx.lineTo(150, 130); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(215, 60); ctx.lineTo(215, 130); ctx.lineTo(150, 130); ctx.stroke();
    }
</script>
</body>
</html>