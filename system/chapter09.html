<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 9: Virtual Memory</title>
    <link rel="stylesheet" href="../assets/style.css">
    <!-- 
    ⚠️ 중요: PDF 전체 페이지 확인
    - PDF의 마지막 페이지 번호: 48
    - 이 HTML에 포함된 마지막 페이지: 48
    - 두 값이 일치합니다!
    -->
</head>
<body data-first-section="sec-basic">

<div class="sidebar">
    <div class="brand">⚡ Logic Master<br><span style="font-weight:400; font-size:0.9rem; opacity:0.8;">Final Edition</span></div>
    <div class="menu-label">Chapter 9. Virtual Memory</div>
    <div class="nav-item active" onclick="showSection('sec-basic', this)"><span class="nav-icon">📚</span> 1. 기본 개념</div>
    <div class="nav-item" onclick="showSection('sec-caching', this)"><span class="nav-icon">💾</span> 2. VM as Caching</div>
    <div class="nav-item" onclick="showSection('sec-management', this)"><span class="nav-icon">🗂️</span> 3. Memory Management</div>
    <div class="nav-item" onclick="showSection('sec-protection', this)"><span class="nav-icon">🔒</span> 4. Memory Protection</div>
    <div class="nav-item" onclick="showSection('sec-translation', this)"><span class="nav-icon">🔄</span> 5. Address Translation</div>
    <div class="nav-item" onclick="showSection('sec-examples', this)"><span class="nav-icon">📊</span> 6. Examples</div>
    <div class="nav-item" onclick="showSection('sec-summary', this)"><span class="nav-icon">📚</span> 7. Summary</div>
</div>

<div class="main">
    <!-- 섹션 1: 기본 개념 -->
    <div id="sec-basic" class="section-container active">
        <div class="header"><h1>1. Virtual Memory 기본 개념</h1><p>가상 메모리의 개념과 주소 공간</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('physical-vs-virtual')">
                <span class="card-icon">🖥️</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>Physical vs Virtual Addressing</h3>
                <p>물리 주소와 가상 주소의 차이. 현대 시스템에서 가상 주소 사용 이유.</p>
                <div class="btn-learn">기본 개념 보기 (page 3~4)</div>
            </div>
            <div class="card" onclick="openModal('address-spaces')">
                <span class="card-icon">🗺️</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>Address Spaces</h3>
                <p>Linear, Virtual, Physical 주소 공간의 개념과 차이점.</p>
                <div class="btn-learn">주소 공간 이해하기 (page 5)</div>
            </div>
            <div class="card" onclick="openModal('why-vm')">
                <span class="card-icon">❓</span>
                <div class="tag-container"><span class="tag exam">중요</span></div>
                <h3>Why Virtual Memory?</h3>
                <p>가상 메모리를 사용하는 이유: 효율성, 단순화, 격리.</p>
                <div class="btn-learn">이유 분석 (page 6)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 2: VM as Caching -->
    <div id="sec-caching" class="section-container">
        <div class="header"><h1>2. VM as a Tool for Caching</h1><p>디스크를 캐시하는 DRAM</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('vm-caching')">
                <span class="card-icon">💾</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>VM as Caching</h3>
                <p>가상 메모리를 디스크의 캐시로 사용. Virtual Pages와 Physical Pages.</p>
                <div class="btn-learn">캐싱 원리 보기 (page 8)</div>
            </div>
            <div class="card" onclick="openModal('dram-cache')">
                <span class="card-icon">⚡</span>
                <div class="tag-container"><span class="tag logic">구조</span></div>
                <h3>DRAM Cache Organization</h3>
                <p>큰 페이지 크기, Fully Associative, Write-back 정책의 이유.</p>
                <div class="btn-learn">구조 분석 (page 9)</div>
            </div>
            <div class="card" onclick="openModal('page-tables')">
                <span class="card-icon">📋</span>
                <div class="tag-container"><span class="tag exam">시험 빈출</span></div>
                <h3>Page Tables</h3>
                <p>가상 페이지를 물리 페이지로 매핑하는 페이지 테이블 구조.</p>
                <div class="btn-learn">페이지 테이블 이해 (page 10~15)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 3: Memory Management -->
    <div id="sec-management" class="section-container">
        <div class="header"><h1>3. VM as a Tool for Memory Management</h1><p>메모리 관리의 단순화</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('vm-management')">
                <span class="card-icon">🗂️</span>
                <div class="tag-container"><span class="tag core">개념</span></div>
                <h3>Memory Management</h3>
                <p>각 프로세스가 동일한 선형 주소 공간을 가지는 이점.</p>
                <div class="btn-learn">관리 원리 보기 (page 20~21)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 4: Memory Protection -->
    <div id="sec-protection" class="section-container">
        <div class="header"><h1>4. VM as a Tool for Memory Protection</h1><p>프로세스 간 메모리 격리</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('vm-protection')">
                <span class="card-icon">🔒</span>
                <div class="tag-container"><span class="tag exam">중요</span></div>
                <h3>Memory Protection</h3>
                <p>프로세스 간 메모리 격리. 커널 정보 보호.</p>
                <div class="btn-learn">보호 메커니즘 (page 24)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 5: Address Translation -->
    <div id="sec-translation" class="section-container">
        <div class="header"><h1>5. Address Translation</h1><p>가상 주소를 물리 주소로 변환</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('address-translation')">
                <span class="card-icon">🔄</span>
                <div class="tag-container"><span class="tag exam">시험 빈출</span></div>
                <h3>Address Translation</h3>
                <p>가상 주소를 물리 주소로 변환하는 과정. VPN, PPN, VPO, PPO.</p>
                <div class="btn-learn">변환 과정 보기 (page 26~38)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 6: Examples -->
    <div id="sec-examples" class="section-container">
        <div class="header"><h1>6. Simple Memory System Example</h1><p>실제 주소 변환 예제</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('simple-system')">
                <span class="card-icon">📊</span>
                <div class="tag-container"><span class="tag logic">예제</span><span class="tag core">Interactive</span></div>
                <h3>Simple Memory System</h3>
                <p>14-bit 가상 주소, 12-bit 물리 주소, 64-byte 페이지 크기 시스템.</p>
                <div class="btn-learn">시스템 구조 보기 (page 41~43)</div>
            </div>
            <div class="card" onclick="openModal('tlb-structure')">
                <span class="card-icon">⚡</span>
                <div class="tag-container"><span class="tag logic">구조</span></div>
                <h3>TLB (Translation Lookaside Buffer)</h3>
                <p>16 entries, 4-way associative TLB 구조와 동작.</p>
                <div class="btn-learn">TLB 구조 분석 (page 27, 32~35)</div>
            </div>
            <div class="card" onclick="openModal('translation-examples')">
                <span class="card-icon">🔢</span>
                <div class="tag-container"><span class="tag exam">시험 빈출</span><span class="tag core">Interactive</span></div>
                <h3>Address Translation Examples</h3>
                <p>실제 가상 주소를 물리 주소로 변환하는 단계별 예제.</p>
                <div class="btn-learn">변환 예제 보기 (page 45~47)</div>
            </div>
            <div class="card" onclick="openModal('translation-example3')">
                <span class="card-icon">📝</span>
                <div class="tag-container"><span class="tag exam">시험 빈출</span><span class="tag logic">연습</span></div>
                <h3>Address Translation Example #3</h3>
                <p>가상 주소 0x0B8F를 물리 주소로 변환하는 연습 문제.</p>
                <div class="btn-learn">연습 문제 보기 (page 47)</div>
            </div>
            <div class="card" onclick="openModal('cache-organization')">
                <span class="card-icon">⚙️</span>
                <div class="tag-container"><span class="tag logic">구조</span></div>
                <h3>Cache Organization</h3>
                <p>Simple Memory System의 캐시 구조. Direct mapped 캐시.</p>
                <div class="btn-learn">캐시 구조 보기 (page 44)</div>
            </div>
        </div>
    </div>

    <!-- 섹션 7: Summary -->
    <div id="sec-summary" class="section-container">
        <div class="header"><h1>7. Summary & Review</h1><p>전체 내용 요약 및 핵심 정리</p></div>
        <div class="grid">
            <div class="card" onclick="openModal('vm-summary')">
                <span class="card-icon">📚</span>
                <div class="tag-container"><span class="tag core">요약</span></div>
                <h3>Virtual Memory Summary</h3>
                <p>전체 내용 요약. Programmer's view와 System view.</p>
                <div class="btn-learn">전체 요약 보기 (page 48)</div>
            </div>
            <div class="card" onclick="openModal('key-concepts')">
                <span class="card-icon">🔑</span>
                <div class="tag-container"><span class="tag exam">핵심</span></div>
                <h3>Key Concepts</h3>
                <p>이번 챕터에서 반드시 알아야 할 핵심 개념들.</p>
                <div class="btn-learn">핵심 정리 보기 (page 48)</div>
            </div>
        </div>
    </div>
</div>

<!-- 모달 오버레이 -->
<div class="modal-overlay" id="modalOverlay" onclick="window.closeModal()">
    <div class="modal-content" onclick="event.stopPropagation()">
        <div class="modal-header">
            <div class="modal-title" id="modalTitle">제목</div>
            <button class="close-btn" onclick="window.closeModal()">✕</button>
        </div>
        <div class="modal-body" id="modalBody">내용</div>
    </div>
</div>

<script src="../assets/common.js"></script>

<script>
    // ============================================
    // 1. 모달 제목 정의
    // ============================================
    window.modalTitles = {
        'physical-vs-virtual': 'Physical vs Virtual Addressing',
        'address-spaces': 'Address Spaces',
        'why-vm': 'Why Virtual Memory?',
        'vm-caching': 'VM as a Tool for Caching',
        'dram-cache': 'DRAM Cache Organization',
        'page-tables': 'Page Tables',
        'vm-management': 'VM as a Tool for Memory Management',
        'vm-protection': 'VM as a Tool for Memory Protection',
        'address-translation': 'Address Translation',
        'simple-system': 'Simple Memory System Example',
        'tlb-structure': 'TLB Structure',
        'translation-examples': 'Address Translation Examples',
        'translation-example3': 'Address Translation Example #3',
        'cache-organization': 'Cache Organization',
        'vm-summary': 'Virtual Memory Summary',
        'key-concepts': 'Key Concepts'
    };

    // ============================================
    // 2. 모달 콘텐츠 정의
    // ============================================
    window.contents = {
        'physical-vs-virtual': `
            <h3>Physical vs Virtual Addressing</h3>
            <p><strong>Physical Addressing (물리 주소 지정):</strong> 메모리 주소가 직접 물리 메모리 위치를 가리키는 방식</p>
            <p><strong>Virtual Addressing (가상 주소 지정):</strong> 메모리 주소가 가상 주소 공간을 가리키고, 하드웨어가 물리 주소로 변환하는 방식</p>
            
            <canvas id="cvs_addressing"></canvas>
            
            <div class="easy-explain">
                <h4>💡 Physical Addressing</h4>
                <ul>
                    <li><strong>사용:</strong> 임베디드 마이크로컨트롤러 (자동차, 엘리베이터, 디지털 액자 등)</li>
                    <li><strong>특징:</strong> 단순하지만 메모리 관리가 어렵고, 프로세스 간 격리가 어려움</li>
                </ul>
            </div>
            
            <div class="easy-explain">
                <h4>💡 Virtual Addressing</h4>
                <ul>
                    <li><strong>사용:</strong> 모든 현대 서버, 데스크톱, 랩톱</li>
                    <li><strong>특징:</strong> 컴퓨터 과학의 위대한 아이디어 중 하나</li>
                    <li><strong>장점:</strong> 메모리 관리 단순화, 프로세스 격리, 보안 강화</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>가상 주소는 하드웨어(MMU)에 의해 자동으로 물리 주소로 변환됩니다. 프로그래머는 가상 주소만 신경 쓰면 됩니다.</p>
            </div>
        `,

        'address-spaces': `
            <h3>Address Spaces (주소 공간)</h3>
            <p><strong>Linear Address Space (선형 주소 공간):</strong> 연속된 비음수 정수 주소들의 정렬된 집합</p>
            <p><strong>Virtual Address Space (가상 주소 공간):</strong> N=2^n개의 가상 주소 집합</p>
            <p><strong>Physical Address Space (물리 주소 공간):</strong> M=2^m개의 물리 주소 집합</p>
            
            <div class="math-block">
                Linear: {0, 1, 2, 3, ...}<br>
                Virtual: {0, 1, 2, 3, ..., N-1} where N = 2^n<br>
                Physical: {0, 1, 2, 3, ..., M-1} where M = 2^m
            </div>
            
            <div class="easy-explain">
                <h4>💡 주소 공간의 특징</h4>
                <ul>
                    <li><strong>데이터와 주소의 명확한 구분:</strong> 데이터(바이트)와 그 속성(주소)을 명확히 구분</li>
                    <li><strong>다중 주소:</strong> 각 객체는 이제 여러 주소를 가질 수 있음</li>
                    <li><strong>메인 메모리의 각 바이트:</strong> 하나의 물리 주소, 하나 이상의 가상 주소</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>가상 주소 공간은 물리 주소 공간보다 훨씬 클 수 있습니다. 예를 들어, 32비트 시스템에서 가상 주소 공간은 4GB이지만, 실제 물리 메모리는 그보다 작을 수 있습니다.</p>
            </div>
        `,

        'why-vm': `
            <h3>Why Virtual Memory? (가상 메모리를 사용하는 이유)</h3>
            <p>가상 메모리는 세 가지 주요 목적을 제공합니다.</p>
            
            <div class="easy-explain">
                <h4>💡 1. 메인 메모리 효율적 사용</h4>
                <ul>
                    <li>가상 주소 공간의 일부를 DRAM 캐시로 사용</li>
                    <li>자주 사용되는 페이지만 메모리에 유지</li>
                    <li>드물게 사용되는 페이지는 디스크에 저장</li>
                </ul>
            </div>
            
            <div class="easy-explain">
                <h4>💡 2. 메모리 관리 단순화</h4>
                <ul>
                    <li>각 프로세스가 동일한 균일한 선형 주소 공간을 가짐</li>
                    <li>프로그래머가 물리 메모리 위치를 신경 쓸 필요 없음</li>
                    <li>연속된 가상 주소 공간 제공 (실제 물리 메모리는 분산되어 있어도 OK)</li>
                </ul>
            </div>
            
            <div class="easy-explain">
                <h4>💡 3. 주소 공간 격리</h4>
                <ul>
                    <li>한 프로세스가 다른 프로세스의 메모리를 간섭할 수 없음</li>
                    <li>사용자 프로그램이 특권 커널 정보에 접근할 수 없음</li>
                    <li>보안 강화</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>가상 메모리는 <strong>효율성</strong>, <strong>단순화</strong>, <strong>격리</strong>를 동시에 제공하는 강력한 메커니즘입니다.</p>
            </div>
        `,

        'vm-caching': `
            <h3>VM as a Tool for Caching</h3>
            <p><strong>Virtual Memory (가상 메모리):</strong> 디스크에 저장된 N개의 연속된 바이트 배열</p>
            <p><strong>Page (페이지):</strong> 가상 메모리의 캐시 블록 (크기 P = 2^p 바이트)</p>
            <p><strong>Virtual Page (VP, 가상 페이지):</strong> 디스크에 저장된 가상 페이지</p>
            <p><strong>Physical Page (PP, 물리 페이지):</strong> DRAM에 캐시된 물리 페이지</p>
            <p>가상 메모리의 내용은 물리 메모리(DRAM 캐시)에 캐시됩니다.</p>
            
            <canvas id="cvs_vm_caching"></canvas>
            
            <div class="easy-explain">
                <h4>💡 Virtual Pages vs Physical Pages</h4>
                <ul>
                    <li><strong>Virtual Pages (VPs):</strong> 디스크에 저장된 가상 페이지</li>
                    <li><strong>Physical Pages (PPs):</strong> DRAM에 캐시된 물리 페이지</li>
                    <li><strong>페이지 크기:</strong> 일반적으로 4KB (2^12 바이트)</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>32비트 시스템 예제</h4>
                <p>페이지 크기가 4KB (2^12)인 32비트 컴퓨터에서:</p>
                <ul>
                    <li>가상 주소 공간: 2^32 = 4GB</li>
                    <li>페이지 수: 2^32 / 2^12 = 2^20 = <strong>1M 개의 VP</strong></li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>가상 메모리는 디스크의 캐시입니다. 자주 사용되는 페이지는 DRAM에, 드물게 사용되는 페이지는 디스크에 저장됩니다.</p>
            </div>
        `,

        'dram-cache': `
            <h3>DRAM Cache Organization</h3>
            <p><strong>DRAM Cache Organization (DRAM 캐시 구조):</strong> 엄청난 미스 페널티에 의해 결정되는 구조</p>
            <p><strong>Miss Penalty (미스 페널티):</strong> 캐시 미스 시 디스크에서 페이지를 가져오는 데 걸리는 시간</p>
            <p><strong>Fully Associative (완전 연관):</strong> 모든 가상 페이지를 모든 물리 페이지에 배치할 수 있는 방식</p>
            <p><strong>Write-Back (쓰기 후 복귀):</strong> 변경된 페이지를 즉시 디스크에 쓰지 않고 나중에 쓰는 정책</p>
            
            <div class="tech-note">
                <h4>접근 시간 비교</h4>
                <ul>
                    <li><strong>SRAM:</strong> 가장 빠름 (기준)</li>
                    <li><strong>DRAM:</strong> SRAM보다 약 10배 느림</li>
                    <li><strong>Disk:</strong> DRAM보다 약 10,000배 느림</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 DRAM 캐시의 특징</h4>
                <ol>
                    <li><strong>큰 페이지(블록) 크기:</strong> 일반적으로 4-8KB, 때로는 4MB</li>
                    <li><strong>Fully Associative (완전 연관):</strong> 모든 VP를 모든 PP에 배치 가능</li>
                    <li><strong>큰 매핑 함수:</strong> CPU 캐시와 다른 방식</li>
                    <li><strong>정교한 교체 알고리즘:</strong> 하드웨어로 구현하기 너무 복잡하고 개방적</li>
                    <li><strong>Write-Back:</strong> Write-Through 대신 Write-Back 사용</li>
                </ol>
            </div>
            
            <div class="easy-explain">
                <h4>💡 왜 Fully Associative인가?</h4>
                <p>디스크 접근이 매우 느리기 때문에, 페이지를 어디에 배치할지 최대한 유연하게 선택할 수 있어야 합니다. 따라서 Fully Associative 방식을 사용합니다.</p>
            </div>
            
            <div class="tech-note">
                <h4>교체 알고리즘</h4>
                <p>DRAM 캐시의 교체 알고리즘은 매우 정교하며, 소프트웨어(운영체제)에서 구현됩니다. 하드웨어로는 구현하기 너무 복잡하고 개방적입니다.</p>
            </div>
        `,

        'page-tables': `
            <h3>Page Tables (페이지 테이블)</h3>
            <p><strong>Page Table (페이지 테이블):</strong> 가상 페이지를 물리 페이지로 매핑하는 페이지 테이블 엔트리(PTE) 배열</p>
            <p><strong>PTE (Page Table Entry, 페이지 테이블 엔트리):</strong> 각 가상 페이지에 대한 매핑 정보를 담은 엔트리</p>
            <p><strong>Per-process (프로세스별):</strong> 각 프로세스마다 별도의 페이지 테이블이 있음</p>
            <p><strong>Kernel Data Structure (커널 데이터 구조):</strong> DRAM에 저장된 커널 데이터 구조</p>
            <p><strong>Valid Bit (유효 비트):</strong> 해당 가상 페이지가 물리 메모리에 있는지 여부를 나타내는 비트</p>
            <p><strong>PPN (Physical Page Number, 물리 페이지 번호):</strong> 물리 페이지의 번호</p>
            
            <canvas id="cvs_page_table"></canvas>
            
            <div class="easy-explain">
                <h4>💡 Page Table Entry (PTE) 구조</h4>
                <ul>
                    <li><strong>Valid Bit:</strong> 해당 가상 페이지가 물리 메모리에 있는지 여부</li>
                    <li><strong>Physical Page Number (PPN):</strong> 물리 페이지 번호 (Valid=1일 때)</li>
                    <li><strong>기타 비트:</strong> 권한 비트, Dirty bit 등</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>페이지 테이블 동작</h4>
                <ol>
                    <li>CPU가 가상 주소(VA)를 생성</li>
                    <li>MMU가 가상 페이지 번호(VPN)를 추출</li>
                    <li>페이지 테이블에서 해당 PTE를 찾음</li>
                    <li>Valid bit 확인</li>
                    <li>Valid=1이면 PPN과 VPO를 결합하여 물리 주소 생성</li>
                    <li>Valid=0이면 Page Fault 발생 (디스크에서 페이지 로드 필요)</li>
                </ol>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>페이지 테이블은 각 프로세스마다 존재하며, 커널이 관리합니다. 페이지 테이블 자체도 물리 메모리에 저장되므로, 페이지 테이블을 위한 메모리도 필요합니다.</p>
            </div>
        `,

        'vm-management': `
            <h3>VM as a Tool for Memory Management</h3>
            <p><strong>Memory Management (메모리 관리):</strong> 메모리 할당 및 해제를 관리하는 것</p>
            <p>가상 메모리는 메모리 관리를 크게 단순화합니다.</p>
            
            <div class="easy-explain">
                <h4>💡 메모리 관리 단순화</h4>
                <ul>
                    <li><strong>균일한 주소 공간:</strong> 각 프로세스가 동일한 선형 주소 공간을 가짐</li>
                    <li><strong>연속된 가상 주소:</strong> 프로그래머는 연속된 가상 주소를 사용 (실제 물리 메모리는 분산되어 있어도 OK)</li>
                    <li><strong>동적 메모리 할당:</strong> 가상 페이지를 필요에 따라 할당/해제 가능</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>예시: 여러 프로세스의 메모리 할당</h4>
                <ul>
                    <li><strong>프로세스 A:</strong> 가상 주소 0x400000~0x500000 사용</li>
                    <li><strong>프로세스 B:</strong> 가상 주소 0x400000~0x500000 사용 (같은 가상 주소!)</li>
                    <li><strong>실제 물리 메모리:</strong> 서로 다른 물리 페이지에 매핑됨</li>
                </ul>
                <p>각 프로세스는 동일한 가상 주소를 사용하지만, 실제로는 서로 다른 물리 메모리를 사용합니다.</p>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>가상 메모리를 사용하면 각 프로세스가 독립적인 주소 공간을 가지므로, 메모리 관리가 훨씬 단순해집니다. 프로그래머는 물리 메모리 위치를 신경 쓸 필요가 없습니다.</p>
            </div>
        `,

        'vm-protection': `
            <h3>VM as a Tool for Memory Protection</h3>
            <p><strong>Memory Protection (메모리 보호):</strong> 프로세스 간 메모리 격리 및 접근 제어</p>
            <p>가상 메모리는 메모리 보호를 위한 편리한 중간 지점을 제공합니다.</p>
            
            <div class="easy-explain">
                <h4>💡 메모리 보호 메커니즘</h4>
                <ul>
                    <li><strong>프로세스 격리:</strong> 한 프로세스가 다른 프로세스의 메모리에 접근할 수 없음</li>
                    <li><strong>커널 보호:</strong> 사용자 프로그램이 특권 커널 정보에 접근할 수 없음</li>
                    <li><strong>권한 비트:</strong> 읽기/쓰기/실행 권한 제어</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>페이지 테이블의 권한 비트</h4>
                <ul>
                    <li><strong>SUP (Supervisor):</strong> 커널 모드에서만 접근 가능</li>
                    <li><strong>READ:</strong> 읽기 권한</li>
                    <li><strong>WRITE:</strong> 쓰기 권한</li>
                    <li><strong>EXEC:</strong> 실행 권한</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>가상 메모리는 권한 검사를 위한 편리한 중간 지점(Interpositioning Point)을 제공합니다. MMU가 주소 변환 시 권한을 확인하므로, 잘못된 접근을 하드웨어 레벨에서 차단할 수 있습니다.</p>
            </div>
        `,

        'address-translation': `
            <h3>Address Translation (주소 변환)</h3>
            <p><strong>Address Translation (주소 변환):</strong> 가상 주소를 물리 주소로 변환하는 과정</p>
            <p><strong>VPN (Virtual Page Number, 가상 페이지 번호):</strong> 가상 주소에서 페이지 번호 부분</p>
            <p><strong>VPO (Virtual Page Offset, 가상 페이지 오프셋):</strong> 가상 주소에서 페이지 내 바이트 오프셋</p>
            <p><strong>PPN (Physical Page Number, 물리 페이지 번호):</strong> 물리 주소에서 페이지 번호 부분</p>
            <p><strong>PPO (Physical Page Offset, 물리 페이지 오프셋):</strong> 물리 주소에서 페이지 내 바이트 오프셋 (VPO와 동일)</p>
            
            <canvas id="cvs_address_translation"></canvas>
            
            <div class="tech-note">
                <h4>주소 구성 요소</h4>
                <ul>
                    <li><strong>VPN (Virtual Page Number):</strong> 가상 페이지 번호</li>
                    <li><strong>VPO (Virtual Page Offset):</strong> 페이지 내 바이트 오프셋</li>
                    <li><strong>PPN (Physical Page Number):</strong> 물리 페이지 번호</li>
                    <li><strong>PPO (Physical Page Offset):</strong> 물리 페이지 내 바이트 오프셋 (VPO와 동일)</li>
                </ul>
            </div>
            
            <div class="easy-explain">
                <h4>💡 주소 변환 과정</h4>
                <ol>
                    <li><strong>가상 주소 분해:</strong> VA를 VPN과 VPO로 분해</li>
                    <li><strong>페이지 테이블 조회:</strong> VPN을 인덱스로 사용하여 PTE 찾기</li>
                    <li><strong>Valid Bit 확인:</strong> Valid=1이면 계속, Valid=0이면 Page Fault</li>
                    <li><strong>물리 주소 생성:</strong> PPN + VPO = Physical Address</li>
                </ol>
            </div>
            
            <div class="math-block">
                Virtual Address = [VPN] [VPO]<br>
                Physical Address = [PPN] [PPO] (where PPO = VPO)
            </div>
            
            <div class="exam-point">
                <h4>🚩 핵심 포인트</h4>
                <p>VPO와 PPO는 항상 동일합니다. 페이지 크기가 같기 때문에 페이지 내 오프셋은 변하지 않습니다.</p>
            </div>
        `,

        'simple-system': `
            <h3>Simple Memory System Example</h3>
            <p><strong>Addressing (주소 지정):</strong></p>
            <p><strong>Virtual Address (가상 주소):</strong> 14비트로 표현되는 가상 주소</p>
            <p><strong>Physical Address (물리 주소):</strong> 12비트로 표현되는 물리 주소</p>
            <p><strong>Page Size (페이지 크기):</strong> 64 바이트 (2^6)</p>
            <ul>
                <li>14-bit 가상 주소</li>
                <li>12-bit 물리 주소</li>
                <li>페이지 크기 = 64 바이트 (2^6)</li>
            </ul>
            
            <div class="tab-container">
                <div class="tab-header">
                    <button class="tab-btn active" onclick="window.switchTab('overview', this)">개요</button>
                    <button class="tab-btn" onclick="window.switchTab('sim', this)">시뮬레이션</button>
                </div>
                
                <div id="tab-overview" class="tab-pane active">
                    <div class="tech-note">
                        <h4>주소 구성</h4>
                        <ul>
                            <li><strong>가상 주소:</strong> 14비트 = 2^14 = 16,384개의 가상 주소</li>
                            <li><strong>물리 주소:</strong> 12비트 = 2^12 = 4,096개의 물리 주소</li>
                            <li><strong>페이지 크기:</strong> 64 바이트 = 2^6</li>
                            <li><strong>가상 페이지 수:</strong> 2^14 / 2^6 = 2^8 = 256개</li>
                            <li><strong>물리 페이지 수:</strong> 2^12 / 2^6 = 2^6 = 64개</li>
                        </ul>
                    </div>
                    
                    <div class="tech-note">
                        <h4>주소 비트 분해</h4>
                        <ul>
                            <li><strong>VPN:</strong> 상위 8비트 (14 - 6 = 8)</li>
                            <li><strong>VPO:</strong> 하위 6비트</li>
                            <li><strong>PPN:</strong> 상위 6비트 (12 - 6 = 6)</li>
                            <li><strong>PPO:</strong> 하위 6비트 (VPO와 동일)</li>
                        </ul>
                    </div>
                    
                    <div class="exam-point">
                        <h4>🚩 핵심 포인트</h4>
                        <p>이 예제 시스템은 작지만 실제 시스템의 동작 원리를 이해하는 데 도움이 됩니다. 주소 변환 과정을 단계별로 따라가면서 학습할 수 있습니다.</p>
                    </div>
                </div>
                
                <div id="tab-sim" class="tab-pane">
                    <p>주소 변환 과정을 단계별로 시뮬레이션해보세요.</p>
                    <div class="sim-box">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                            <div style="background: #fef3c7; padding: 15px; border-radius: 12px;">
                                <div style="font-weight: 700; margin-bottom: 10px;">Virtual Address</div>
                                <div style="font-size: 1.5rem; color: var(--primary);" id="va-display">0x0000</div>
                            </div>
                            <div style="background: #dbeafe; padding: 15px; border-radius: 12px;">
                                <div style="font-weight: 700; margin-bottom: 10px;">Physical Address</div>
                                <div style="font-size: 1.5rem; color: var(--accent);" id="pa-display">0x0000</div>
                            </div>
                        </div>
                        <div class="sim-log" id="translation-log">👇 버튼을 눌러 주소 변환 과정을 시뮬레이션하세요.</div>
                        <div class="sim-controls">
                            <button onclick="window.nextTranslationStep()">다음 단계 진행 ▶</button>
                        </div>
                    </div>
                </div>
            </div>
        `,

        'tlb-structure': `
            <h3>TLB (Translation Lookaside Buffer)</h3>
            <p><strong>TLB (Translation Lookaside Buffer, 변환 색인 버퍼):</strong> 페이지 테이블 조회를 빠르게 하기 위한 하드웨어 캐시</p>
            <p><strong>TLB Hit (TLB 히트):</strong> TLB에서 VPN을 찾아 즉시 PPN을 반환하는 경우</p>
            <p><strong>TLB Miss (TLB 미스):</strong> TLB에서 VPN을 찾지 못해 페이지 테이블을 조회해야 하는 경우</p>
            <p><strong>4-way Associative (4-way 집합 연관):</strong> 각 Set에 4개의 엔트리가 있는 캐시 구조</p>
            
            <div class="tech-note">
                <h4>Simple Memory System TLB</h4>
                <ul>
                    <li><strong>16 entries:</strong> 16개의 엔트리</li>
                    <li><strong>4-way associative:</strong> 4-way 집합 연관</li>
                    <li><strong>구성:</strong> Set, Tag, PPN, Valid</li>
                </ul>
            </div>
            
            <table>
                <tr>
                    <th>Set</th>
                    <th>Tag</th>
                    <th>PPN</th>
                    <th>Valid</th>
                    <th>Tag</th>
                    <th>PPN</th>
                    <th>Valid</th>
                    <th>Tag</th>
                    <th>PPN</th>
                    <th>Valid</th>
                    <th>Tag</th>
                    <th>PPN</th>
                    <th>Valid</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>03</td>
                    <td>-</td>
                    <td>0</td>
                    <td>09</td>
                    <td>0D</td>
                    <td>1</td>
                    <td>00</td>
                    <td>-</td>
                    <td>0</td>
                    <td>07</td>
                    <td>02</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>03</td>
                    <td>2D</td>
                    <td>1</td>
                    <td>02</td>
                    <td>-</td>
                    <td>0</td>
                    <td>04</td>
                    <td>-</td>
                    <td>0</td>
                    <td>0A</td>
                    <td>-</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>02</td>
                    <td>-</td>
                    <td>0</td>
                    <td>08</td>
                    <td>-</td>
                    <td>0</td>
                    <td>06</td>
                    <td>-</td>
                    <td>0</td>
                    <td>03</td>
                    <td>-</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>07</td>
                    <td>-</td>
                    <td>0</td>
                    <td>03</td>
                    <td>0D</td>
                    <td>1</td>
                    <td>0A</td>
                    <td>34</td>
                    <td>1</td>
                    <td>02</td>
                    <td>-</td>
                    <td>0</td>
                </tr>
            </table>
            
            <div class="easy-explain">
                <h4>💡 TLB의 역할</h4>
                <p>페이지 테이블은 메모리에 있기 때문에 접근이 느립니다. TLB는 최근에 사용된 VPN→PPN 매핑을 캐시하여 주소 변환 속도를 높입니다.</p>
            </div>
            
            <div class="exam-point">
                <h4>🚩 TLB Hit vs Miss</h4>
                <ul>
                    <li><strong>TLB Hit:</strong> TLB에서 VPN을 찾으면 즉시 PPN 반환 (빠름)</li>
                    <li><strong>TLB Miss:</strong> TLB에서 찾지 못하면 페이지 테이블 조회 필요 (느림)</li>
                </ul>
            </div>
        `,

        'translation-examples': `
            <h3>Address Translation Examples</h3>
            <p><strong>Address Translation (주소 변환):</strong> 가상 주소를 물리 주소로 변환하는 과정</p>
            <p><strong>TLBI (TLB Index, TLB 인덱스):</strong> TLB Set을 선택하는 비트</p>
            <p><strong>TLBT (TLB Tag, TLB 태그):</strong> TLB에서 VPN을 식별하는 태그 비트</p>
            <p>실제 가상 주소를 물리 주소로 변환하는 단계별 예제입니다.</p>
            
            <div class="tab-container">
                <div class="tab-header">
                    <button class="tab-btn active" onclick="window.switchTab('example1', this)">예제 1</button>
                    <button class="tab-btn" onclick="window.switchTab('example2', this)">예제 2</button>
                    <button class="tab-btn" onclick="window.switchTab('example3', this)">예제 3</button>
                </div>
                
                <div id="tab-example1" class="tab-pane active">
                    <h4>예제 1: Virtual Address 0x03D4</h4>
                    <div class="tech-note">
                        <h4>주소 분해</h4>
                        <ul>
                            <li><strong>가상 주소:</strong> 0x03D4 = 0000 1111 0101 0100 (2진수)</li>
                            <li><strong>VPN:</strong> 상위 8비트 = 0x0F</li>
                            <li><strong>VPO:</strong> 하위 6비트 = 0x14</li>
                        </ul>
                    </div>
                    
                    <div class="tech-note">
                        <h4>TLB 조회</h4>
                        <ul>
                            <li><strong>TLBI:</strong> VPN의 하위 2비트 = 0x3 (Set 3)</li>
                            <li><strong>TLBT:</strong> VPN의 상위 6비트 = 0x03</li>
                            <li><strong>TLB Hit?</strong> Set 3에서 Tag 0x03 찾기 → <strong>Y (Hit!)</strong></li>
                            <li><strong>PPN:</strong> 0x0D</li>
                        </ul>
                    </div>
                    
                    <div class="tech-note">
                        <h4>캐시 조회</h4>
                        <ul>
                            <li><strong>물리 주소:</strong> PPN(0x0D) + VPO(0x14) = 0x354</li>
                            <li><strong>CI:</strong> 하위 4비트 = 0x5</li>
                            <li><strong>CT:</strong> 상위 6비트 = 0x0D</li>
                            <li><strong>Hit?</strong> <strong>Y</strong></li>
                            <li><strong>Byte:</strong> 0x36</li>
                        </ul>
                    </div>
                </div>
                
                <div id="tab-example2" class="tab-pane">
                    <h4>예제 2: Virtual Address 0x0020</h4>
                    <div class="tech-note">
                        <h4>주소 분해</h4>
                        <ul>
                            <li><strong>가상 주소:</strong> 0x0020 = 0000 0000 0010 0000 (2진수)</li>
                            <li><strong>VPN:</strong> 상위 8비트 = 0x00</li>
                            <li><strong>VPO:</strong> 하위 6비트 = 0x20</li>
                        </ul>
                    </div>
                    
                    <div class="tech-note">
                        <h4>TLB 조회</h4>
                        <ul>
                            <li><strong>TLBI:</strong> 0x0 (Set 0)</li>
                            <li><strong>TLBT:</strong> 0x00</li>
                            <li><strong>TLB Hit?</strong> Set 0에서 Tag 0x00 찾기 → <strong>N (Miss)</strong></li>
                        </ul>
                    </div>
                    
                    <div class="tech-note">
                        <h4>페이지 테이블 조회</h4>
                        <ul>
                            <li><strong>페이지 테이블:</strong> VPN 0x00 → PPN 0x28, Valid=1</li>
                            <li><strong>물리 주소:</strong> PPN(0x28) + VPO(0x20) = 0x2A0</li>
                        </ul>
                    </div>
                    
                    <div class="tech-note">
                        <h4>캐시 조회</h4>
                        <ul>
                            <li><strong>CI:</strong> 0x8</li>
                            <li><strong>CT:</strong> 0x28</li>
                            <li><strong>Hit?</strong> <strong>Y</strong></li>
                            <li><strong>Byte:</strong> 메모리에서 읽음</li>
                        </ul>
                    </div>
                </div>
                
                <div id="tab-example3" class="tab-pane">
                    <h4>예제 3: Virtual Address 0x0B8F</h4>
                    <p>이 예제는 연습 문제로 남겨둡니다. 위의 예제 1, 2를 참고하여 직접 풀어보세요.</p>
                    
                    <div class="exam-point">
                        <h4>🚩 연습 문제</h4>
                        <ol>
                            <li>가상 주소 0x0B8F를 VPN과 VPO로 분해하세요.</li>
                            <li>TLB를 조회하여 Hit/Miss를 판단하세요.</li>
                            <li>TLB Miss인 경우 페이지 테이블을 조회하세요.</li>
                            <li>물리 주소를 생성하고 캐시를 조회하세요.</li>
                        </ol>
                    </div>
                </div>
            </div>
        `,

        'translation-example3': `
            <h3>Address Translation Example #3</h3>
            <p><strong>Virtual Address (가상 주소):</strong> 0x0B8F</p>
            <p>이 예제는 연습 문제입니다. 예제 1, 2를 참고하여 직접 풀어보세요.</p>
            
            <div class="tab-container">
                <div class="tab-header">
                    <button class="tab-btn active" onclick="window.switchTab('problem', this)">문제</button>
                    <button class="tab-btn" onclick="window.switchTab('hint', this)">힌트</button>
                    <button class="tab-btn" onclick="window.switchTab('solution', this)">해답</button>
                </div>
                
                <div id="tab-problem" class="tab-pane active">
                    <div class="exam-point">
                        <h4>🚩 연습 문제</h4>
                        <p>가상 주소 <strong>0x0B8F</strong>를 물리 주소로 변환하세요.</p>
                        <ol>
                            <li>가상 주소 0x0B8F를 VPN과 VPO로 분해하세요.</li>
                            <li>TLB를 조회하여 Hit/Miss를 판단하세요.
                                <ul>
                                    <li>TLBI와 TLBT를 계산하세요.</li>
                                    <li>TLB 테이블에서 해당 Set을 확인하세요.</li>
                                </ul>
                            </li>
                            <li>TLB Miss인 경우 페이지 테이블을 조회하세요.</li>
                            <li>물리 주소를 생성하세요 (PPN + VPO).</li>
                            <li>캐시를 조회하여 최종 바이트 값을 찾으세요.</li>
                        </ol>
                    </div>
                    
                    <div class="tech-note">
                        <h4>참고: Simple Memory System 구조</h4>
                        <ul>
                            <li>14-bit 가상 주소, 12-bit 물리 주소</li>
                            <li>페이지 크기: 64 바이트 (2^6)</li>
                            <li>VPN: 상위 8비트, VPO: 하위 6비트</li>
                            <li>TLB: 16 entries, 4-way associative</li>
                            <li>캐시: 16 lines, 4-byte block size, Direct mapped</li>
                        </ul>
                    </div>
                </div>
                
                <div id="tab-hint" class="tab-pane">
                    <div class="easy-explain">
                        <h4>💡 힌트</h4>
                        <ol>
                            <li><strong>주소 분해:</strong>
                                <ul>
                                    <li>0x0B8F = 0000 1011 1000 1111 (2진수)</li>
                                    <li>상위 8비트 = VPN</li>
                                    <li>하위 6비트 = VPO</li>
                                </ul>
                            </li>
                            <li><strong>TLB 조회:</strong>
                                <ul>
                                    <li>TLBI = VPN의 하위 2비트</li>
                                    <li>TLBT = VPN의 상위 6비트</li>
                                    <li>해당 Set에서 Tag가 일치하는 엔트리 찾기</li>
                                </ul>
                            </li>
                            <li><strong>페이지 테이블:</strong> TLB Miss인 경우 VPN을 인덱스로 사용</li>
                            <li><strong>물리 주소:</strong> PPN + VPO</li>
                            <li><strong>캐시:</strong> CI = 하위 4비트, CT = 상위 6비트</li>
                        </ol>
                    </div>
                </div>
                
                <div id="tab-solution" class="tab-pane">
                    <div class="tech-note">
                        <h4>1. 주소 분해</h4>
                        <ul>
                            <li><strong>가상 주소:</strong> 0x0B8F = 0000 1011 1000 1111 (2진수)</li>
                            <li><strong>VPN:</strong> 상위 8비트 = 0x0B</li>
                            <li><strong>VPO:</strong> 하위 6비트 = 0x0F</li>
                        </ul>
                    </div>
                    
                    <div class="tech-note">
                        <h4>2. TLB 조회</h4>
                        <ul>
                            <li><strong>TLBI:</strong> VPN의 하위 2비트 = 0x3 (Set 3)</li>
                            <li><strong>TLBT:</strong> VPN의 상위 6비트 = 0x02</li>
                            <li><strong>TLB 조회:</strong> Set 3에서 Tag 0x02 찾기</li>
                            <li>Set 3의 엔트리들: Tag 0x07 (PPN=-, Valid=0), Tag 0x03 (PPN=0x0D, Valid=1), Tag 0x0A (PPN=0x34, Valid=1), Tag 0x02 (PPN=-, Valid=0)</li>
                            <li><strong>TLB Hit?</strong> <strong>N (Miss!)</strong> - Tag 0x02는 Valid=0이므로 Miss</li>
                        </ul>
                    </div>
                    
                    <div class="tech-note">
                        <h4>3. 페이지 테이블 조회</h4>
                        <ul>
                            <li><strong>페이지 테이블:</strong> VPN 0x0B → PPN = -, Valid = 0</li>
                            <li><strong>Page Fault!</strong> 해당 가상 페이지가 물리 메모리에 없음</li>
                            <li>디스크에서 페이지를 로드해야 함</li>
                        </ul>
                    </div>
                    
                    <div class="exam-point">
                        <h4>🚩 결론</h4>
                        <p>가상 주소 0x0B8F는 <strong>Page Fault</strong>를 발생시킵니다.</p>
                        <p>해당 가상 페이지(VPN 0x0B)가 물리 메모리에 없으므로, 운영체제가 디스크에서 페이지를 로드해야 합니다.</p>
                    </div>
                </div>
            </div>
        `,

        'cache-organization': `
            <h3>Cache Organization (캐시 구조)</h3>
            <p><strong>Cache (캐시):</strong> 물리 메모리의 일부를 캐시하는 하드웨어</p>
            <p><strong>Direct Mapped (직접 매핑):</strong> 각 메모리 블록이 정확히 하나의 캐시 라인에만 매핑되는 방식</p>
            
            <div class="tech-note">
                <h4>Simple Memory System 캐시 구조</h4>
                <ul>
                    <li><strong>16 lines:</strong> 16개의 캐시 라인</li>
                    <li><strong>4-byte block size:</strong> 각 블록은 4바이트</li>
                    <li><strong>Physically addressed:</strong> 물리 주소로 캐시 접근</li>
                    <li><strong>Direct mapped:</strong> 직접 매핑 방식</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>캐시 주소 구성 요소</h4>
                <ul>
                    <li><strong>CO (Cache Offset, 캐시 오프셋):</strong> 블록 내 바이트 오프셋 (2비트, 4바이트 블록이므로)</li>
                    <li><strong>CI (Cache Index, 캐시 인덱스):</strong> 캐시 라인 인덱스 (4비트, 16라인이므로)</li>
                    <li><strong>CT (Cache Tag, 캐시 태그):</strong> 캐시 태그 (나머지 비트)</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>12-bit 물리 주소 분해</h4>
                <ul>
                    <li><strong>CO:</strong> 하위 2비트 (블록 내 오프셋)</li>
                    <li><strong>CI:</strong> 다음 4비트 (캐시 라인 인덱스)</li>
                    <li><strong>CT:</strong> 상위 6비트 (태그)</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 Direct Mapped 캐시 동작</h4>
                <ol>
                    <li>물리 주소에서 CI를 추출하여 해당 캐시 라인 선택</li>
                    <li>해당 라인의 Valid bit 확인</li>
                    <li>Valid=1이면 CT와 비교하여 Hit/Miss 판단</li>
                    <li>Hit이면 CO를 사용하여 블록 내 바이트 선택</li>
                    <li>Miss이면 메모리에서 블록을 로드</li>
                </ol>
            </div>
            
            <div class="tech-note">
                <h4>캐시 테이블 예시</h4>
                <table>
                    <tr>
                        <th>Idx</th>
                        <th>Tag</th>
                        <th>Valid</th>
                        <th>B0</th>
                        <th>B1</th>
                        <th>B2</th>
                        <th>B3</th>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>19</td>
                        <td>1</td>
                        <td>99</td>
                        <td>11</td>
                        <td>23</td>
                        <td>11</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>0D</td>
                        <td>1</td>
                        <td>36</td>
                        <td>72</td>
                        <td>F0</td>
                        <td>1D</td>
                    </tr>
                    <tr>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                        <td>...</td>
                    </tr>
                </table>
            </div>
            
            <div class="exam-point">
                <h4>🚩 캐시 Hit/Miss 판단</h4>
                <ul>
                    <li><strong>Cache Hit:</strong> Valid=1이고 CT가 일치하면 Hit</li>
                    <li><strong>Cache Miss:</strong> Valid=0이거나 CT가 일치하지 않으면 Miss</li>
                    <li>Miss인 경우 메모리에서 블록을 로드하고 태그 업데이트</li>
                </ul>
            </div>
        `,

        'vm-summary': `
            <h3>Virtual Memory Summary</h3>
            <p>가상 메모리의 전체 요약입니다.</p>
            
            <div class="tab-container">
                <div class="tab-header">
                    <button class="tab-btn active" onclick="window.switchTab('programmer', this)">Programmer's View</button>
                    <button class="tab-btn" onclick="window.switchTab('system', this)">System View</button>
                </div>
                
                <div id="tab-programmer" class="tab-pane active">
                    <h4>Programmer's View of Virtual Memory</h4>
                    <div class="exam-point">
                        <h4>🚩 프로그래머 관점</h4>
                        <ul>
                            <li>각 프로세스는 자신만의 <strong>개인 선형 주소 공간</strong>을 가짐</li>
                            <li>다른 프로세스에 의해 <strong>손상될 수 없음</strong></li>
                            <li>연속된 가상 주소 공간 제공</li>
                            <li>물리 메모리 위치를 신경 쓸 필요 없음</li>
                        </ul>
                    </div>
                </div>
                
                <div id="tab-system" class="tab-pane">
                    <h4>System View of Virtual Memory</h4>
                    <div class="exam-point">
                        <h4>🚩 시스템 관점</h4>
                        <ul>
                            <li>가상 메모리 페이지를 <strong>캐싱</strong>하여 메모리를 효율적으로 사용</li>
                            <li><strong>지역성(Locality)</strong> 때문에만 효율적</li>
                            <li>메모리 관리와 프로그래밍을 <strong>단순화</strong></li>
                            <li>권한 검사를 위한 <strong>편리한 중간 지점</strong> 제공하여 보호 단순화</li>
                        </ul>
                    </div>
                </div>
            </div>
        `,

        'key-concepts': `
            <h3>Key Concepts (핵심 정리)</h3>
            <p>이번 챕터에서 반드시 알아야 할 핵심 개념들을 정리했습니다.</p>
            
            <div class="exam-point">
                <h4>🚩 1. Address Spaces</h4>
                <ul>
                    <li><strong>Virtual Address Space:</strong> N=2^n개의 가상 주소</li>
                    <li><strong>Physical Address Space:</strong> M=2^m개의 물리 주소</li>
                    <li><strong>각 바이트:</strong> 하나의 물리 주소, 하나 이상의 가상 주소</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 2. VM as Caching</h4>
                <ul>
                    <li><strong>Virtual Pages:</strong> 디스크에 저장</li>
                    <li><strong>Physical Pages:</strong> DRAM에 캐시</li>
                    <li><strong>페이지 크기:</strong> 일반적으로 4KB</li>
                    <li><strong>Fully Associative:</strong> 모든 VP를 모든 PP에 배치 가능</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 3. Page Tables</h4>
                <ul>
                    <li><strong>구조:</strong> PTE 배열 (VPN → PPN 매핑)</li>
                    <li><strong>Per-process:</strong> 각 프로세스마다 별도의 페이지 테이블</li>
                    <li><strong>Valid Bit:</strong> 페이지가 메모리에 있는지 여부</li>
                </ul>
            </div>
            
            <div class="exam-point">
                <h4>🚩 4. Address Translation</h4>
                <ul>
                    <li><strong>VPN:</strong> 가상 페이지 번호</li>
                    <li><strong>VPO:</strong> 가상 페이지 오프셋</li>
                    <li><strong>PPN:</strong> 물리 페이지 번호</li>
                    <li><strong>PPO:</strong> 물리 페이지 오프셋 (VPO와 동일)</li>
                </ul>
            </div>
            
            <div class="tech-note">
                <h4>📝 시험 대비 체크리스트</h4>
                <ul>
                    <li>✅ 가상 주소를 물리 주소로 변환하는 과정</li>
                    <li>✅ TLB Hit/Miss 판단 방법</li>
                    <li>✅ 페이지 테이블 조회 과정</li>
                    <li>✅ VPN, VPO, PPN, PPO 비트 분해</li>
                    <li>✅ Simple Memory System 예제 풀이</li>
                    <li>✅ Page Fault 처리 과정</li>
                    <li>✅ Direct Mapped 캐시 구조 및 Hit/Miss 판단</li>
                    <li>✅ 캐시 주소 구성 요소 (CO, CI, CT)</li>
                </ul>
            </div>
        `
    };

    // ============================================
    // 3. Canvas 다이어그램 그리기 함수들
    // ============================================
    
    function drawAddressing() {
        var c = document.getElementById('cvs_addressing');
        if (!c) {
            console.warn('Canvas cvs_addressing not found');
            return;
        }
        var ctx = c.getContext('2d');
        var w = c.width = c.clientWidth || 600;
        var h = c.height = 240;
        ctx.clearRect(0, 0, w, h);
        ctx.lineWidth = 2;
        ctx.font = "bold 14px sans-serif";
        
        // Physical Addressing
        ctx.fillStyle = "#1e293b";
        ctx.fillRect(50, 30, 200, 80);
        ctx.fillStyle = "#fff";
        ctx.fillText("CPU", 70, 55);
        ctx.fillText("Physical Address", 60, 75);
        
        ctx.fillStyle = "#4f46e5";
        ctx.fillRect(300, 30, 200, 80);
        ctx.fillStyle = "#fff";
        ctx.fillText("Physical Memory", 320, 55);
        ctx.fillText("Direct Access", 320, 75);
        
        ctx.strokeStyle = "#f43f5e";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(250, 70);
        ctx.lineTo(300, 70);
        ctx.stroke();
        
        // Virtual Addressing
        ctx.fillStyle = "#1e293b";
        ctx.fillRect(50, 140, 200, 80);
        ctx.fillStyle = "#fff";
        ctx.fillText("CPU", 70, 165);
        ctx.fillText("Virtual Address", 60, 185);
        
        ctx.fillStyle = "#10b981";
        ctx.fillRect(300, 140, 100, 80);
        ctx.fillStyle = "#fff";
        ctx.fillText("MMU", 320, 165);
        ctx.fillText("Translation", 310, 185);
        
        ctx.fillStyle = "#4f46e5";
        ctx.fillRect(450, 140, 200, 80);
        ctx.fillStyle = "#fff";
        ctx.fillText("Physical Memory", 470, 165);
        ctx.fillText("Translated", 480, 185);
        
        ctx.strokeStyle = "#f43f5e";
        ctx.beginPath();
        ctx.moveTo(250, 180);
        ctx.lineTo(300, 180);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(400, 180);
        ctx.lineTo(450, 180);
        ctx.stroke();
        
        // 설명
        ctx.fillStyle = "#334155";
        ctx.font = "11px sans-serif";
        ctx.fillText("Physical: 직접 접근", 50, 250);
        ctx.fillText("Virtual: MMU를 통한 변환", 300, 250);
    }
    
    function drawVMCaching() {
        var c = document.getElementById('cvs_vm_caching');
        if (!c) {
            console.warn('Canvas cvs_vm_caching not found');
            return;
        }
        var ctx = c.getContext('2d');
        var w = c.width = c.clientWidth || 600;
        var h = c.height = 300;
        ctx.clearRect(0, 0, w, h);
        ctx.lineWidth = 2;
        ctx.font = "bold 14px sans-serif";
        
        // Disk (Virtual Pages)
        ctx.fillStyle = "#64748b";
        ctx.fillRect(50, 40, 200, 100);
        ctx.strokeRect(50, 40, 200, 100);
        ctx.fillStyle = "#fff";
        ctx.fillText("Disk", 120, 70);
        ctx.font = "12px sans-serif";
        ctx.fillText("Virtual Pages (VPs)", 60, 95);
        ctx.fillText("Stored on disk", 70, 115);
        
        // DRAM (Physical Pages)
        ctx.fillStyle = "#4f46e5";
        ctx.fillRect(350, 40, 200, 100);
        ctx.strokeRect(350, 40, 200, 100);
        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText("DRAM Cache", 400, 70);
        ctx.font = "12px sans-serif";
        ctx.fillText("Physical Pages (PPs)", 360, 95);
        ctx.fillText("Cached in DRAM", 375, 115);
        
        // 화살표
        ctx.strokeStyle = "#f43f5e";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(250, 90);
        ctx.lineTo(350, 90);
        ctx.stroke();
        
        // 설명
        ctx.fillStyle = "#334155";
        ctx.font = "12px sans-serif";
        ctx.fillText("가상 메모리는 디스크의 캐시입니다", 50, 180);
        ctx.fillText("자주 사용되는 페이지만 DRAM에 캐시됩니다", 50, 200);
        ctx.fillText("페이지 크기: 일반적으로 4KB (2^12 바이트)", 50, 220);
    }
    
    function drawPageTable() {
        var c = document.getElementById('cvs_page_table');
        if (!c) {
            console.warn('Canvas cvs_page_table not found');
            return;
        }
        var ctx = c.getContext('2d');
        var w = c.width = c.clientWidth || 600;
        var h = c.height = 320;
        ctx.clearRect(0, 0, w, h);
        ctx.lineWidth = 2;
        ctx.font = "bold 14px sans-serif";
        
        // Page Table
        ctx.fillStyle = "#e0e7ff";
        ctx.fillRect(50, 40, 250, 200);
        ctx.strokeRect(50, 40, 250, 200);
        ctx.fillStyle = "#1e293b";
        ctx.fillText("Page Table (DRAM)", 100, 65);
        
        // PTE entries
        ctx.font = "11px sans-serif";
        ctx.fillText("PTE[0]: PPN=0x28, Valid=1", 60, 90);
        ctx.fillText("PTE[1]: PPN=-, Valid=0", 60, 110);
        ctx.fillText("PTE[2]: PPN=0x33, Valid=1", 60, 130);
        ctx.fillText("PTE[3]: PPN=0x02, Valid=1", 60, 150);
        ctx.fillText("...", 60, 170);
        ctx.fillText("PTE[VPN]: PPN, Valid", 60, 190);
        
        // Virtual Pages
        ctx.fillStyle = "#fef3c7";
        ctx.fillRect(350, 40, 200, 80);
        ctx.strokeRect(350, 40, 200, 80);
        ctx.fillStyle = "#1e293b";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText("Virtual Pages", 380, 65);
        ctx.font = "12px sans-serif";
        ctx.fillText("VPN 0, 1, 2, 3, ...", 360, 90);
        
        // Physical Pages
        ctx.fillStyle = "#dbeafe";
        ctx.fillRect(350, 160, 200, 80);
        ctx.strokeRect(350, 160, 200, 80);
        ctx.fillStyle = "#1e293b";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText("Physical Pages", 375, 185);
        ctx.font = "12px sans-serif";
        ctx.fillText("PPN 0x28, 0x33, 0x02, ...", 355, 210);
        
        // 화살표
        ctx.strokeStyle = "#10b981";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(300, 80);
        ctx.lineTo(350, 80);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(300, 200);
        ctx.lineTo(350, 200);
        ctx.stroke();
        
        // 설명
        ctx.fillStyle = "#334155";
        ctx.font = "12px sans-serif";
        ctx.fillText("페이지 테이블: VPN → PPN 매핑", 50, 280);
        ctx.fillText("각 프로세스마다 별도의 페이지 테이블", 50, 300);
    }
    
    function drawAddressTranslation() {
        var c = document.getElementById('cvs_address_translation');
        if (!c) {
            console.warn('Canvas cvs_address_translation not found');
            return;
        }
        var ctx = c.getContext('2d');
        var w = c.width = c.clientWidth || 600;
        var h = c.height = 360;
        ctx.clearRect(0, 0, w, h);
        ctx.lineWidth = 2;
        ctx.font = "bold 14px sans-serif";
        
        // Virtual Address
        ctx.fillStyle = "#fef3c7";
        ctx.fillRect(50, 30, 500, 50);
        ctx.strokeRect(50, 30, 500, 50);
        ctx.fillStyle = "#1e293b";
        ctx.fillText("Virtual Address", 60, 55);
        
        // VPN
        ctx.fillStyle = "#fee2e2";
        ctx.fillRect(200, 30, 200, 50);
        ctx.fillStyle = "#1e293b";
        ctx.fillText("VPN", 280, 55);
        
        // VPO
        ctx.fillStyle = "#dbeafe";
        ctx.fillRect(400, 30, 150, 50);
        ctx.fillStyle = "#1e293b";
        ctx.fillText("VPO", 460, 55);
        
        // 화살표
        ctx.strokeStyle = "#f43f5e";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(300, 90);
        ctx.lineTo(300, 130);
        ctx.stroke();
        
        // Page Table
        ctx.fillStyle = "#e0e7ff";
        ctx.fillRect(200, 130, 200, 80);
        ctx.strokeRect(200, 130, 200, 80);
        ctx.fillStyle = "#1e293b";
        ctx.fillText("Page Table", 260, 155);
        ctx.font = "12px sans-serif";
        ctx.fillText("PTE[VPN] → PPN", 220, 180);
        ctx.fillText("Valid Bit Check", 230, 195);
        
        // 화살표
        ctx.beginPath();
        ctx.moveTo(300, 220);
        ctx.lineTo(300, 260);
        ctx.stroke();
        
        // Physical Address
        ctx.fillStyle = "#dbeafe";
        ctx.fillRect(50, 260, 500, 50);
        ctx.strokeRect(50, 260, 500, 50);
        ctx.fillStyle = "#1e293b";
        ctx.font = "bold 14px sans-serif";
        ctx.fillText("Physical Address", 60, 285);
        
        // PPN
        ctx.fillStyle = "#fee2e2";
        ctx.fillRect(200, 260, 200, 50);
        ctx.fillStyle = "#1e293b";
        ctx.fillText("PPN", 280, 285);
        
        // PPO
        ctx.fillStyle = "#dbeafe";
        ctx.fillRect(400, 260, 150, 50);
        ctx.fillStyle = "#1e293b";
        ctx.fillText("PPO (same as VPO)", 410, 285);
        
        // 설명
        ctx.fillStyle = "#334155";
        ctx.font = "12px sans-serif";
        ctx.fillText("1. VA를 VPN과 VPO로 분해", 50, 340);
        ctx.fillText("2. 페이지 테이블에서 PPN 찾기", 250, 340);
        ctx.fillText("3. PPN + VPO = Physical Address", 450, 340);
    }
    
    // ============================================
    // 4. 시뮬레이션 함수들 (Interactive 태그가 있는 모달용)
    // ============================================
    
    // Address Translation 시뮬레이션 (Simple Memory System)
    window.nextTranslationStep = function() {
        var log = document.getElementById('translation-log');
        var vaDisplay = document.getElementById('va-display');
        var paDisplay = document.getElementById('pa-display');
        
        if (!log) return;
        
        if (window.simStep === 0) {
            // 1단계: 가상 주소 입력
            if (vaDisplay) vaDisplay.textContent = '0x03D4';
            log.innerHTML = "<strong>1단계:</strong> 가상 주소 0x03D4를 VPN과 VPO로 분해합니다.<br>→ VPN = 0x0F (상위 8비트), VPO = 0x14 (하위 6비트)";
            window.simStep++;
        } else if (window.simStep === 1) {
            // 2단계: TLB 조회
            log.innerHTML = "<strong>2단계:</strong> TLB 조회<br>→ TLBI = 0x3 (Set 3), TLBT = 0x03<br>→ <strong>TLB Hit!</strong> PPN = 0x0D";
            window.simStep++;
        } else if (window.simStep === 2) {
            // 3단계: 물리 주소 생성
            if (paDisplay) paDisplay.textContent = '0x354';
            log.innerHTML = "<strong>3단계:</strong> 물리 주소 생성<br>→ PPN(0x0D) + VPO(0x14) = <strong>0x354</strong>";
            window.simStep++;
        } else if (window.simStep === 3) {
            // 4단계: 캐시 조회
            log.innerHTML = "<strong>4단계:</strong> 캐시 조회<br>→ CI = 0x5, CT = 0x0D<br>→ <strong>Cache Hit!</strong> Byte = 0x36";
            window.simStep++;
        } else {
            // 리셋
            if (vaDisplay) vaDisplay.textContent = '0x0000';
            if (paDisplay) paDisplay.textContent = '0x0000';
            log.innerText = "다시 시작하려면 버튼을 누르세요.";
            window.simStep = 0;
        }
    };
    
    // 모달 열기 전처리
    window.onModalOpening = function(id) {
        if (id === 'simple-system' || id === 'translation-examples') {
            setTimeout(function() {
                var log = document.getElementById('translation-log');
                var vaDisplay = document.getElementById('va-display');
                var paDisplay = document.getElementById('pa-display');
                if (log) {
                    log.innerText = "👇 버튼을 눌러 주소 변환 과정을 시뮬레이션하세요.";
                    if (vaDisplay) vaDisplay.textContent = '0x0000';
                    if (paDisplay) paDisplay.textContent = '0x0000';
                    window.simStep = 0;
                }
            }, 50);
        }
    };
    
    // 캔버스 그리기 훅
    window.runCanvasDrawing = function(id) {
        if (id === 'physical-vs-virtual') drawAddressing();
        else if (id === 'vm-caching') drawVMCaching();
        else if (id === 'page-tables') drawPageTable();
        else if (id === 'address-translation') drawAddressTranslation();
    };
</script>
</body>
</html>

